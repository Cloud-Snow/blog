<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/3/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">594</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">539</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/05/2025spring-rust-based-os-comp-stage2-report-loichyan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/05/2025spring-rust-based-os-comp-stage2-report-loichyan/" class="post-title-link" itemprop="url">2025春夏季开源操作系统训练营第二阶段总结报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-05 20:31:32" itemprop="dateCreated datePublished" datetime="2025-05-05T20:31:32+00:00">2025-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-06 06:28:39" itemprop="dateModified" datetime="2025-05-06T06:28:39+00:00">2025-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">2025春夏季开源操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="学习历程"><a href="#学习历程" class="headerlink" title="学习历程"></a>学习历程</h2><p>因为并非计算机专业出身，所以一直都有系统学习计算机底层原理的念头，趁着备研把理论性的知识学了一些．虽然现阶段只看了计算机组成原理，不过，早便萌生了自己动手去实践那些理论技巧的想法．去年秋冬季的夏令营也有报名，但由于时间安排仓促混乱，只得作罢．今年，虽然学习安排亦比较紧张，不过，想着动手得来的知识要比苦读书本记忆的更为深刻．</p>
<p>在第一阶段中，因为本身就有一些 Rust 开发经验，所以总体上是复习了一遍语言基础，前后并没有占用多少时间．第二阶段开始的时间稍晚，在 4 月下旬才腾出时间来专门研读 rCore 教程，也算是为了接下来学习操作系统做铺垫吧．一直拖沓的月底才把 rCore 教程 V3<a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/" target="_blank" rel="noopener">^1</a> 看完，五月初到现在差不多 4 天的时间完成了各章节的实验题目．</p>
<h2 id="主要收获"><a href="#主要收获" class="headerlink" title="主要收获"></a>主要收获</h2><p>在阅读 rCore 教程的时候，始终有两个问题一直困扰我，在 rCore 的实现中，</p>
<ol>
<li>内核虚拟内存空间和用户虚存被映射到了相同的地址段，这导致除了访问用户指针时需要先映射到实际的物理内存，稍有遗漏便可能导致访存异常，能否使用一个页表呢？</li>
<li>每个任务都有两个栈，即内核栈和用户栈，并且在调度任务时需要反复地在不同内核栈之间轮替，能否使用一个单独的栈解决问题呢？</li>
</ol>
<h3 id="单页表虚拟内存"><a href="#单页表虚拟内存" class="headerlink" title="单页表虚拟内存"></a>单页表虚拟内存</h3><p>单页表的实现在教程中有所提及，关于为何没有使用，文中给出的理由是单页表会导致熔断攻击．如果要避免熔断攻击，那么用户态就一定不能包含内核空间的页表项，这一点很容易想到．再稍加思考，只需要将地址空间一分为二，高位和低位分别留给内核和用户，然后再维护两个页表，其中一个只包含用户程序和必要的内核程序即可．后来，进一步研究了 Linux 的 PTI<a href="https://www.kernel.org/doc/html/next/x86/pti.html" target="_blank" rel="noopener">^2</a> 机制后，发现基本的思路一致．并且从中了解到，在实现细节上，可以将两个页表放在物理内存的两个连续页面上，这样只需要若干寄存器运算就能实现换表．</p>
<p>起初我一直认为单页表无疑是比双页表更简洁方便的方案．后来，在落实时才发现，实现单页表的一大难点在于：内核被映射到虚拟内存的高位（比如 0xffffffc080200000），但实际上被加载到物理内存的低位运行（比如 0x80200000）．这便到导致了内核链接时的基址和运行时的基址不一致，从而可能使得某些绝对寻址的访存错误，进一步引发难以察觉的 BUG．故，需要在内核启动时，需要手写一小段仅使用相对寻址的汇编代码来构造一个最小可用的内核页表，然后再进行更为细致地初始化流程．</p>
<p>在这个过程中，本打算参考 ArceOS<a href="https://github.com/arceos-org/arceos/" target="_blank" rel="noopener">^3</a> 的实现，但此内核中直接在若干简短的 Rust 函数中完成了初始化．猜测应该是编译成了位置无关的代码，但总感觉这样有些”过度“依赖于编译器．因此，经过一番探索之后，用大约 50 行汇编代码完成了最小内核页表的初始化工作．这个过程是比较困难的，因为整个系统还没有启动，非常难以调试．不过也因此深化了对 GDB 等调试工具的理解和使用．</p>
<p>此外，在更进一步地思考后，发现每个程序的内核页表都是该程序初始化时的全局内核页表的一个拷贝，如果后续内核页表更新，可能会导致访存的不一致．对于此问题，最简单的办法就是预先分配好三级页表的全部项，这样后续就完全不必担心同步的问题．当然，这不可避免的占用了少量额外内存（更确切地，2MB），但这个“少量”对于嵌入式设备来说并非可接受的开销．因此，最好的方案似乎还是按需同步，考虑到内核页表不会变化太频繁，这应该是一个合理的选择．不过，最终该如何漂亮地解决这个问题，还需要进一步的调研．</p>
<h3 id="单内核栈系统"><a href="#单内核栈系统" class="headerlink" title="单内核栈系统"></a>单内核栈系统</h3><p>刚开始学习多任务时，就一直纠结单内核栈该怎么实现．后来学习进程管理机制时，突然意识到，如果换一个角度看待用户程序：对操作系统来说，执行用户程序相当于调用一个函数，只不过，函数的返回依赖于陷入机制．这一点和用户角度很像，即不发生异常时，大多数时候，操作系统对于用户程序就是一个提供了许多系统调用的函数库．用户程序可以在一个栈上“不间断地”执行（陷入处理对用户透明），那么操作系统肯定也能实现类似的机制．</p>
<p>对于进一步的细节，相当于将 rCore 的上下文切换和用户执行态恢复整合一起：每次需要执行用户程序时，将当前的内核运行状态保存；而在处理用户陷入时，保存过用户的执行状态后，紧接着便加载先前保存的内核状态．整体上看，相当于内核把用户视为函数调用了一次，而在它返回后，内核便可以着手进行调度或者处理用户请求．</p>
<p>这样，一个最显著的优点便是使得内核的调度更加直观：从始自终，内核在一个循环中不断地“call”用户程序．并且，可以大幅减少全局变量的使用，更容易利用 Rust 所有权模型的优势，也有利好内核实现复杂的调度算法．</p>
<h3 id="两阶段陷入处理"><a href="#两阶段陷入处理" class="headerlink" title="两阶段陷入处理"></a>两阶段陷入处理</h3><p>上述单内核栈的方案也引发了一个新问题：每次发生陷入都要保存大量寄存器，包括全部的用户通用寄存器、CSR 以及一部分调用上下文；而多内核栈的方案中，不发生调度时，相比可以减少约 2/3 的寄存器存取操作．因此，自然而然地，需要找到一种方法来减少上下文的保存操作．</p>
<p>由陷入机制入手，从本质上讲，陷入处理实际上是在任意位置插入一条函数调用，而各种处理器架构均定义了汇编层面的调用约定．既然陷入处理相当于函数调用，那么在陷入处理的入点，只需要保存调用者（caller-saved）寄存器和若干其它寄存器（CSR、tp、sp 等）即可．后来，偶然发现了 rCore 维护者提出的 fast-trap<a href="https://github.com/rustsbi/fast-trap/" target="_blank" rel="noopener">^4</a> 快速陷入处理机制，这是一个相当通用（但有些复杂）的多阶段陷入处理机制．</p>
<p>深入研究之后，发现似乎两个阶段的陷入处理机制就能满足绝大部分的需求：</p>
<ol>
<li>第一阶段，只需要保存约一半的寄存器（如上文所述），主要用于处理各种异常（包括内核和用户）以及一部分不需要切换上下文的系统调用．处理内核陷入仅需要此阶段即可．</li>
<li>第二阶段，保存完整的用户寄存器和内核调用上下文，沿用前文单内核栈方案的陷入处理机制．</li>
</ol>
<p>在经过大量试错和调整之后，最终在不需要额外的访存操作的情况下，实现了一个相对通用的两阶段陷入处理方案．实现时，更进一步学习了许多 GDB 的调试技巧以及 Rust 声明宏的使用技巧．</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上便是第二阶段中的主要收获，此外，关于文件系统和各种同步原语的实现，也偶有一些“灵光一现”，不过限于时间不足，并没来得及实践．对于下一阶段，打算集中精力攻克第三个选题，即基于 Rust 语言异步机制的内核改造．因为，此前一直对 Rust 的异步实现“耿耿于怀”，借此机会，可以更深入理解其工作原理．</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/03/2025%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E7%8E%8B%E6%89%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/03/2025%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E7%8E%8B%E6%89%AC/" class="post-title-link" itemprop="url">2025开源操作系统训练营总结-王扬</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-03 09:57:17" itemprop="dateCreated datePublished" datetime="2025-05-03T09:57:17+00:00">2025-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-06 06:28:39" itemprop="dateModified" datetime="2025-05-06T06:28:39+00:00">2025-05-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="rcore-总结"><a href="#rcore-总结" class="headerlink" title="rcore 总结"></a>rcore 总结</h1><h2 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h2><h3 id="最终设计思路"><a href="#最终设计思路" class="headerlink" title="最终设计思路"></a>最终设计思路</h3><ol>
<li>在每个task下用<code>syscall_count:[u8;MAX_SYSCALL_ID]</code>存下调用次数，</li>
<li>在<code>mod.rs</code>中为<code>TaskManager</code>实现<code>incerment</code>和<code>get</code>方法<h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3></li>
<li>以为不同task在一起统计，后来询问群友得知分开统计。（感觉文档里最好应该说清楚）</li>
<li>一开始想用<code>hashmap</code>存，后面发现在<code>no std</code>下使用要用<code>hashbrown</code>库，但没有实现<code>Clone</code>，就不能用</li>
<li>在task中用一个数组存syscall的count，数组如果用<code>usize</code>不知道为什么<code>write A B C</code>的时候会卡住(可能太大了==???==)，尝试用<code>u8</code>就成功了</li>
</ol>
<h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><h3 id="最终设计思路-1"><a href="#最终设计思路-1" class="headerlink" title="最终设计思路"></a>最终设计思路</h3><ol>
<li><code>sys_mmap</code>:遍历vpns，使用<code>translate</code>建立vpn和ppn映射</li>
<li><code>sys_unmmap</code>：遍历vpns，使用<code>memory_set.page_table.unmap(...)</code>取消映射</li>
<li><code>sys_get_timer</code>:获取当前时间的微秒值并转换为 <code>TimeVal</code> 结构体获取其字节数组<code>time_val_bytes</code>，然后将其拷贝到用户空间的目标地址对应字节数组位置<code>dst:Vec&lt;&amp; mut[u8]&gt;</code>。</li>
<li><code>sys_trace</code>: 根据id得vpn+offset，使用<code>translate</code>获取其物理地址进行读写</li>
</ol>
<h3 id="踩坑记录-1"><a href="#踩坑记录-1" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><ol>
<li>首先尝试实现<code>sys_mmap</code>，一开始想<code>impl TaskManager</code>中实现<code>get_memoryset</code>方法，尝试后发现返回<code>&amp;</code>会有生命周期问题，试了很久后放弃了。直接在<code>mod.rs</code>实现一个<code>map_vpns_to_ppns</code></li>
<li><code>sys_get_time</code>一开始没用<code>translated_byte_buffer</code>，用完后简化很多。然后遇到：<ol>
<li>如何把<code>time_val</code>转为字节数组<code>time_val_bytes</code>。：<code>core::slice::from_raw_parts</code></li>
<li>如何把<code>time_val_bytes</code>复制到<code>dst:Vec&lt;&amp; mut[u8]&gt;</code>。 : <code>core::ptr::copy_nonoverlapping</code></li>
</ol>
</li>
<li>不小心直接把id转为ppn</li>
<li>没有设置用户空间地址上限</li>
</ol>
<h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ol>
<li><code>spawn</code> 系统调用 结合 <code>fork</code> 和 <code>exec</code>将两部分结合即可，试一次就成功了，没遇到什么问题</li>
<li>stride 调度算法：主要需要在task里新加一个<code>prio</code>属性，然后修改fetch方法，一个坑是修改<code>highest_tcb.stride</code>是生命周期有问题要用一个{}块去限制</li>
</ol>
<h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><h3 id="实现过程-1"><a href="#实现过程-1" class="headerlink" title="实现过程"></a>实现过程</h3><ol>
<li>主要是需要在<code>inode</code>里实现<code>link</code> <code>unlink</code>仿照<code>clear</code>方法，先定义<code>op</code>找到<code>old_name</code>节点，接着调用<code>modify_disk_inode</code>方法，在最后添加一项设置对应<code>inode_id</code>与<code>old</code>的相同即可。要记得<code>block_cache_sync_all()</code>确保数据刷回磁盘</li>
<li>踩坑：一开始没有仔细看文档，easy-fs的文件全部挂在根目录下啊</li>
</ol>
<h2 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h2><h3 id="算法记录"><a href="#算法记录" class="headerlink" title="算法记录"></a>算法记录</h3><p>定义如下三个数据结构：<br>可利用资源向量 Available ：含有 m 个元素的一维数组，每个元素代表可利用的某一类资源的数目， 其初值是该类资源的全部可用数目，其值随该类资源的分配和回收而动态地改变。 Available[j] = k，表示第 j 类资源的可用数量为 k。<br>分配矩阵 Allocation：n * m 矩阵，表示每类资源已分配给每个线程的资源数。 Allocation[i,j] = g，则表示线程 i 当前己分得第 j 类资源的数量为 g。<br>需求矩阵 Need：n * m 的矩阵，表示每个线程还需要的各类资源数量。 Need[i,j] = d，则表示线程 i 还需要第 j 类资源的数量为 d 。<br>算法运行过程如下：<br>设置两个向量: 工作向量 Work，表示操作系统可提供给线程继续运行所需的各类资源数目，它含有 m 个元素。初始时，Work = Available ；结束向量 Finish，表示系统是否有足够的资源分配给线程， 使之运行完成。初始时 Finish[0..n-1] = false，表示所有线程都没结束；当有足够资源分配给线程时， 设置 Finish[i] = true。<br>从线程集合中找到一个能满足下述条件的线程<br>1Finish[i] == false;<br>2Need[i,j] &lt;= Work[j];<br>若找到，执行步骤 3，否则执行步骤 4。<br>当线程 thr[i] 获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行:<br>1Work[j] = Work[j] + Allocation[i, j];<br>2Finish[i] = true;<br>跳转回步骤2<br>如果 Finish[0..n-1] 都为 true，则表示系统处于安全状态；否则表示系统处于不安全状态，即出现死锁。</p>
<h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><ol>
<li><code>enable_deadlock_detect</code>只负责检查是否<code>enable</code>,具体实现在<code>check_dead_mutex</code>和<code>check_dead_sem</code>还有<code>banker</code></li>
<li>按照上面算法写即可</li>
</ol>
<h1 id="arceos-总结"><a href="#arceos-总结" class="headerlink" title="arceos 总结"></a>arceos 总结</h1><h1 id="1-基础调用流程"><a href="#1-基础调用流程" class="headerlink" title="1 基础调用流程"></a>1 基础调用流程</h1><p>调用组件的流程 :app–&gt;ulib:axstd–&gt;arceos_api–&gt;axhal–&gt;axruntime–&gt;app<br>axhal组件：_start()(初始化页表)–&gt;rust_entry()–&gt;<br>axruntime组件: rust_main()(打印logo+基本信息，初始化日志，显示kernel各各段范围，初始化内存分配器，platform初始化，初始化thread调度器，初始化设备和驱动，初始化文件系统网络系统，初始化中断，等待所有cpu启动)–&gt;<br>apphello_world组件:main()–&gt;<br>axstd组件: println(macros.rs)–&gt;print_impl–&gt;stdout::Write(io.rs)–&gt;<br>arceos_api组件:ax_console_write_bytes–&gt;<br>axhal组件：console write_bytes–&gt;riscv64 put_char–&gt;<br>sbi: putchar</p>
<p>使用features可以自由选择组件</p>
<p>print_with_color实验<br>直接在字符串两端加入颜色字符即可</p>
<h1 id="2-动态内存分配支持"><a href="#2-动态内存分配支持" class="headerlink" title="2 动态内存分配支持"></a>2 动态内存分配支持</h1><p><img src="/blog/.io//2025%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E7%8E%8B%E6%89%AC%5Cimg%5Cimage-2505021.png" alt></p>
<ol>
<li>使用rust trait #[global_allocator]支持rust library中内存分配</li>
<li>支持hashmap思路：使用vec实现，根据key的hash值%hashmap容量作为位置存下value即可</li>
<li>bump_allocator实现思路：[ bytes-used | avail-area | pages-used ] 比较简单记录下三个区域分开的位置即可<h1 id="3-ReadPFlash-引入页表"><a href="#3-ReadPFlash-引入页表" class="headerlink" title="3 ReadPFlash 引入页表"></a>3 ReadPFlash 引入页表</h1></li>
<li>PFlash的作用：Qemu的PFlash模拟闪存磁盘，启动时自动从文件加载内容到固定的MMIO区域，而且对读操作不需要驱动，可以直接访问。</li>
<li>为何不指定”paging”时导致读PFlash失败？ArceOS Unikernel包括两阶段地址空间映射，Boot阶段默认开启1G空间的恒等映射；如果需要支持设备MMIO区间，通过指定一个feature - “paging”来实现重映射。</li>
<li>axhal提供体系结构无关的接口方法set_kernel_page_table写入根页表地址并启用分页</li>
</ol>
<h1 id="4-启动子任务"><a href="#4-启动子任务" class="headerlink" title="4 启动子任务"></a>4 启动子任务</h1><p><img src="/blog/.io//2025%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E7%8E%8B%E6%89%AC%5Cimg%5Cimage-2.png" alt><br>接口公开的是runqueue的对应方法</p>
<ol>
<li>spawn&amp;spawn_raw：产生一个新任务，加入runqueue，处于Ready</li>
<li>yield_now (协作式调度的关键)主动让出CPU执行权</li>
<li>sleep&amp;sleep_until睡眠固定的时间后醒来在timers定时器列表中注册，等待唤醒</li>
<li>exit当前任务退出，标记状态，等待GC回收</li>
</ol>
<h1 id="5-协作式调度算法"><a href="#5-协作式调度算法" class="headerlink" title="5 协作式调度算法"></a>5 协作式调度算法</h1><ol>
<li>context_switch</li>
<li>协作式调度：任务之间通过“友好”协作方式分享CPU资源。具体的，当前任务是否让出和何时让出CPU控制权完全由当前任务自己决定。</li>
</ol>
<h1 id="6-抢占式调度"><a href="#6-抢占式调度" class="headerlink" title="6 抢占式调度"></a>6 抢占式调度</h1><ol>
<li>只有内外条件都满足时，才发生抢占；内部条件举例任务时间片耗尽，外部条件类似定义某种临界区，控制什么时候不能抢占，本质上它基于当前任务的preempt_disable_count。</li>
<li>只在 禁用-&gt;启用 切换的下边沿触发；下边沿通常在自旋锁解锁时产生，此时是切换时机。</li>
<li>推动内部条件变化(例: 任务时间片消耗)和边沿触发产生(例: 自旋锁加解锁)的根本源是时钟中断。</li>
<li>CFS算法<ol>
<li>vruntime最小的任务就是优先权最高任务，即当前任务。计算公式：vruntime = init_vruntime + (delta / weight(nice))系统初始化时，init_vruntime, delta, nice三者都是0</li>
<li>新增任务：新任务的init_vruntime等于min_vruntime即默认情况下新任务能够尽快投入运行</li>
<li>设置优先级set_priority：只有CFS支持设置优先级，即nice值，会影响init_vruntime以及运行中vruntime值，该任务会比默认情况获得更多或更少的运行机会。</li>
<li>任务队列基于BtreeMap，即有序队列，排序基于vruntime</li>
</ol>
</li>
</ol>
<h1 id="7-ReadBlock"><a href="#7-ReadBlock" class="headerlink" title="7 ReadBlock"></a>7 ReadBlock</h1><p><img src="/blog/.io//2025%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E7%8E%8B%E6%89%AC%5Cimg%5Cimage-6.png" alt></p>
<ol>
<li>virtio设备的probe过程<img src="/blog/.io//2025%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E7%8E%8B%E6%89%AC%5Cimg%5Cimage-7.png" alt></li>
<li>virtio驱动和virtio设备交互的两条路：<img src="/blog/.io//2025%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E7%8E%8B%E6%89%AC%5Cimg%5Cimage-8.png" alt><ol>
<li>主要基于vring环形队列:本质上是连续的Page页面，在Guest和Host都可见可写</li>
<li>中断响应的通道主要对等待读取大块数据时是有用。</li>
</ol>
</li>
<li><img src="/blog/.io//2025%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E7%8E%8B%E6%89%AC%5Cimg%5Cimage-9.png" alt></li>
<li>块设备驱动Trait - BlockDriverOps</li>
</ol>
<h1 id="8-加入文件系统"><a href="#8-加入文件系统" class="headerlink" title="8 加入文件系统"></a>8 加入文件系统</h1><p><img src="/blog/.io//2025%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E7%8E%8B%E6%89%AC%5Cimg%5Cimage-10.png" alt></p>
<ol>
<li>文件系统节点的操作流程：第一步：获得Root 目录节点 第二步：解析路径，逐级通过lookup方法找到对应节点，直至目标节点 第三步：对目标节点执行操作</li>
<li>rename_ramfs实验<ol>
<li>实验踩坑1：没有添加patch的部分<code>axfs_ramfs={path=&quot;axfs_ramfs&quot;}</code></li>
<li>实验踩坑2： axfs中rename函数有问题，没有考虑dst的挂载</li>
</ol>
</li>
</ol>
<h1 id="9-引入特权级"><a href="#9-引入特权级" class="headerlink" title="9 引入特权级"></a>9 引入特权级</h1><ol>
<li>分析从Unikernel基础到目标最小化宏内核需要完成的增量工作：<ol>
<li>用户地址空间的创建和区域映射</li>
<li>在异常中断响应的基础上增加系统调用</li>
<li>复用Unikernel原来的调度机制，针对宏内核扩展Task属性</li>
<li>在内核与用户两个特权级之间的切换机制</li>
</ol>
</li>
<li>实例<ol>
<li>为应用创建独立的用户地址空间 涉及组件：axmm</li>
<li>加载应用程序代码到地址空间 涉及组件：axfs，axmm</li>
<li>. 初始化用户栈 涉及组件：axmm</li>
<li>创建用户任务 涉及组件：axtask (with taskext)</li>
<li>让出CPU，使得用户任务运行 涉及组件：axtask，axhal</li>
</ol>
</li>
<li>切使用系统调用时使用异常</li>
</ol>
<h1 id="10-缺页异常与内存映射"><a href="#10-缺页异常与内存映射" class="headerlink" title="10 缺页异常与内存映射"></a>10 缺页异常与内存映射</h1><p><img src="/blog/.io//2025%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E7%8E%8B%E6%89%AC%5Cimg%5Cimage-14.png" alt></p>
<ol>
<li>地址空间区域映射后端Backend，负责针对空间中特定区域的具体的映射操作， Backend从实现角度是一个Trait</li>
<li>如何让Linux的原始应用（二进制）直接在我们的宏内核上直接运行？<br> 在应用和内核交互界面上实现兼容。兼容界面包含三类：<ol>
<li>syscall</li>
<li>procfs &amp; sysfs等伪文件系统</li>
<li>应用、编译器和libc对地址空间的假定，涉及某些参数定义或某些特殊地址的引用</li>
</ol>
</li>
<li>elf格式加载<ol>
<li>需要注意文件内偏移和预定的虚拟内存空间内偏移可能不一致，特别是数据段部分</li>
</ol>
</li>
<li>初始化应用的栈</li>
<li>系统调用层次结构<img src="/blog/.io//2025%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E7%8E%8B%E6%89%AC%5Cimg%5Cimage-17.png" alt></li>
<li>sys_mmap实现：先读到buf，在用户态页表找一片物理地址，转换为内核态地址，然后把buf里的东西复制过去。<h1 id="11-Hypervisor"><a href="#11-Hypervisor" class="headerlink" title="11 Hypervisor"></a>11 Hypervisor</h1></li>
<li>I型：直接在硬件平台上运行 II型：在宿主OS上运行</li>
<li>Hypervisor支撑的资源对象层次：<ol>
<li>VM：管理地址空间；同一整合下级各类资源</li>
<li>vCPU：计算资源虚拟化，VM中执行流</li>
<li>vMem：内存虚拟化，按照VM的物理空间布局</li>
<li>vDevice：设备虚拟化：包括直接映射和模拟</li>
<li>vUtilities：中断虚拟化、总线发现设备等</li>
</ol>
</li>
<li>最简Hypervisor执行流程：<ol>
<li>加载Guest OS内核Image到新建地址空间。</li>
<li>准备虚拟机环境，设置特殊上下文。</li>
<li>结合特殊上下文和指令sret切换到V模式，即VM-ENTRY。</li>
<li>OS内核只有一条指令，调用sbi-call的关机操作。</li>
<li>在虚拟机中，sbi-call超出V模式权限，导致VM-EXIT退出虚拟机，切换回Hypervisor。</li>
<li>Hypervisor响应VM-EXIT的函数检查退出原因和参数，进行处理，由于是请求关机，清理虚拟机后，退出。</li>
</ol>
</li>
<li>Riscv64:M/HS/U形成Host域，用来运行I型Hypervisor或者II型的HostOS，三个特权级的作用不变。VS/VU形成Guest域，用来运行GuestOS，这两个特权级分别对应内核态和用户态。HS是关键，作为联通真实世界和虚拟世界的通道。体系结构设计了双向变迁机制。<br>H扩展后，S模式发送明显变化：原有s[xxx]寄存器组作用不变，新增hs[xxx]和vs[xxx]<br>hs[xxx]寄存器组的作用：面向Guest进行路径控制，例如异常/中断委托等<br>vs[xxx]寄存器组的作用：直接操纵Guest域中的VS，为其准备或设置状态</li>
<li>为进入虚拟化模式准备的条件<ol>
<li>ISA寄存器misa第7位代表Hypervisor扩展的启用/禁止。对这一位写入0，可以禁止H扩展</li>
<li>进入V模式路径的控制：hstatus第7位SPV记录上一次进入HS特权级前的模式，1代表来自虚拟化模式。执行sret时，根据SPV决定是返回用户态，还是返回虚拟化模式。</li>
<li>Hypervisor首次启动Guest的内核之前，伪造上下文作准备：设置Guest的sstatus，让其初始特权级为Supervisor；设置Guest的sepc为OS启动入口地址VM_ENTRY，VM_ENTRY值就是内核启动的入口地址，对于Riscv64，其地址是0x8020_0000。</li>
</ol>
</li>
<li>从Host到Guest的切换run_guest每个vCPU维护一组上下文状态，分别对应Host和Guest。从Hypervisor切断到虚拟机时，暂存Host中部分可能被破坏的状态；加载Guest状态；然后执行sret完成切换。封装该过程的专门函数run_guest。</li>
<li>VM-Exit原因<ol>
<li>执行特权操作</li>
<li>Guest环境的物理地址区间尚未映射，导致二次缺页，切换进入Host环境</li>
</ol>
</li>
<li>simple_hv实验：只需改变sepc寄存器，并将对应值存进对应寄存器</li>
</ol>
<h1 id="12-Hypervisor-两阶段地址映射"><a href="#12-Hypervisor-两阶段地址映射" class="headerlink" title="12 Hypervisor 两阶段地址映射"></a>12 Hypervisor 两阶段地址映射</h1><ol>
<li>有两种处理方式：<ol>
<li>模拟模式 - 为虚拟机模拟一个pflash，以file1为后备文件。当Guest读该设备时，提供file1文件的内容。</li>
<li>透传模式 - 直接把宿主物理机(即qemu)的pflash透传给虚拟机。<br>优劣势：模拟模式可为不同虚拟机提供不同的pflash内容，但效率低；透传模式效率高，但是捆绑了设备。</li>
</ol>
</li>
<li>Hypervisor负责基于HPA面向Guest映射GPA，基本寄存器是hgatp；Guest认为看到的GPA是“实际”的物理空间，它基于satp映射内部的GVA虚拟空间。 GVA–&gt; (vsatp)-&gt;GPA–&gt; (hgatp) -&gt;HPA<img src="/blog/.io//2025%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E7%8E%8B%E6%89%AC%5Cimg%5Cimage-25.png" alt></li>
<li>Hypervisor的主逻辑包含三个部分：<ol>
<li>准备VM的资源：VM地址空间和单个vCPU</li>
<li>切换进入Guest的代码</li>
<li>响应VMExit各种原因的代码</li>
</ol>
</li>
<li><img src="/blog/.io//2025%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E7%8E%8B%E6%89%AC%5Cimg%5Cimage-24.png" alt></li>
<li>相比于宏内核多了vm-entry和vm-exit</li>
</ol>
<h1 id="13-虚拟时钟中断支持；虚拟机外设的支持"><a href="#13-虚拟时钟中断支持；虚拟机外设的支持" class="headerlink" title="13 虚拟时钟中断支持；虚拟机外设的支持"></a>13 虚拟时钟中断支持；虚拟机外设的支持</h1><ol>
<li>物理环境或者qemu模拟器中，时钟中断触发时，能够正常通过stvec寄存器找到异常中断向量表，然后进入事先注册的响应函数。但是在虚拟机环境下，宿主环境下的原始路径失效了。有两种解决方案：<ol>
<li>启用Riscv AIA机制，把特定的中断委托到虚拟机Guest环境下。要求平台支持，且比较复杂。</li>
<li>通过中断注入的方式来实现。即本实验采取的方式。注入机制的关键是寄存器hvip，指示在Guest环境中，哪些中断处于Pending状态。</li>
</ol>
</li>
<li>支持虚拟机时钟中断需要实现两部分的内容：<br><img src="/blog/.io//2025%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E7%8E%8B%E6%89%AC%5Cimg%5Cimage-27.png" alt><ol>
<li>响应虚拟机发出的SBI-Call功能调用SetTimer</li>
<li>响应宿主机时钟中断导致的VM退出，注入到虚拟机内部</li>
</ol>
</li>
<li>具体实现modules/riscv_vcpu/src/vcpu.rs</li>
<li>管理上的层次结构：虚拟机（VM），设备组VmDevGroup以及设备VmDev。Riscv架构下，虚拟机包含的各种外设通常是通过MMIO方式访问，因此主要用地址范围标记它们的资源。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/02/2025%E6%98%A5%E5%A4%8F%E5%AD%A3OS%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/02/2025%E6%98%A5%E5%A4%8F%E5%AD%A3OS%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">2025春夏季OS训练营学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-02 21:39:01" itemprop="dateCreated datePublished" datetime="2025-05-02T21:39:01+00:00">2025-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-06 06:28:39" itemprop="dateModified" datetime="2025-05-06T06:28:39+00:00">2025-05-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>终于完成了前三个阶段的练习。我这个系统方向的博士生，读了很多操作系统方面的论文，但是直到今天终于是脱离了书籍上的一知半解，可以称得上是“了解”操作系统的基本原理了。作为一个转专业学生，我从统计学起步，跨专业申请到了计算机方向的硕士，到现在在异国他乡博士在读。也算是凭着对计算机的热爱走到了现在。只是要在这个领域做出好的问题和好的研究，还是一件很困难的事情。写完最后一个hypervisor实验的感慨倒是适合放在此处： “仔细想想，实际上type-II hypervisor也几乎可以通过类似的机制实现。这一套并不局限于直接运行在硬件上的Type-I Hypervisor，只要硬件提供特权级的隔离的功能可以轻易实现。硬件支持真是个好东西。想到了当时读Xen的论文，通过Para Virtualization重量级实现hypervisor那种巨大的工程量，再到现在各个处理器指令集都支持虚拟化扩展，可以通过几百行代码实现一个简单虚拟机。也算是软件系统的需求促进的硬件发展的一个样例了。<br>时过境迁，前两年Timothy在OSDI疾呼研究者应该回归OS的本质做hardware-software co-design。现在新硬件层出不穷，硬件加速器，智能网卡，TEE，还有RDMA，CXL一堆新名词。好像“攻守之势异也”，变成了硬件推动OS进步了。面对着越来越多的外设和越来越专业化的使用场景，操作系统研究者的未来又在何方呢？”</p>
<p>祝自己将来能成为一名好的system researcher</p>
<h1 id="rcore部分"><a href="#rcore部分" class="headerlink" title="rcore部分"></a>rcore部分</h1><h2 id="Chapter-1-应用程序与基本执行环境"><a href="#Chapter-1-应用程序与基本执行环境" class="headerlink" title="Chapter  1 应用程序与基本执行环境"></a>Chapter  1 应用程序与基本执行环境</h2><p>Ref: <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/index.html" target="_blank" rel="noopener">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/index.html</a><br>作为rCore教程的第一章，这章其实并未涉及到太多OS的概念。而是主要介绍了OS作为一个系统软件和应用层软件的区别：执行环境。并通过代码介绍了编写在OS执行环境中可以执行的代码。<br>我们在之前的学习中编写的用户态代码在执行时依赖于语言提供的运行时+标准库。运行时是一些预编译好的代码，会在编译时与我们自己编写的代码编译在一起，来实现一些诸如数组越界检查等功能。而标准库包含了对于很多系统调用的封装，比如说在使用print时，这个标准库函数在底层调用了操作系统提供的系统调用write 来把希望打印的内容输出到屏幕上。在运行时，操作系统也会帮我们完成准备和收尾工作，比如开辟虚拟内存，将程序代码载入到内存中，并在程序退出后执行清理工作等等等等等等。但是对于OS来说，它直接运行在硬件上，并没有封装好的系统调用，也没有其它软件为他进行准备工作了。因此一切都需要我们使用代码完成。</p>
<p>编译选项</p>
<p>首先就是在编译层面我们需要设置特别的编译选项。默认情况下Rust的编译选项默认标准库和对应的操作系统存在，因此生成代码时会用到其中的功能，这显然是不能接收的。因此我们需要把编译选项中只指定硬件架构RISCV 和基本的二进制文件格式elf 。</p>
<p>设置内存布局</p>
<p>由于没有fork 等系统调用，我们必须自己处理程序启动时的准备工作才能让程序运行起来。好在我们还可以使用rust_sbi 以及系统架构和上面的固件。RISCV固件在加电启动时会默认从内存0x1000 开始运行代码，并帮助我们跳转到rust_sbi 的启动流程中去。rust_sbi 规定系统软件的代码需要被放置在0x800002000 以保证正常执行。因此我们只需要在启动时把编译好的二进制文件load到0x80002000 中去即可。另一点需要注意的是rust的链接器（最终决定二进制内存布局）的默认设置并不符合QEMU中RISCV的要求。因此我们需要手动设置链接器的脚本以确保各个段被放置在合适的位置。从而保证load后能顺利运行</p>
<p>编写代码</p>
<p>由于这一章中仅仅是使用rust_sbi 完成输出Hello World，所以大部分内容属于调用SBI的细节无需赘述。需要注意的有几点，第一是在没有标准库后，代码默认的panic和exit都需要我们进行退出处理（甚至没有标准库的情况下它甚至无法指定默认入口为main 函数，我们需要给代码标注上![no_main] 宏然后在汇编中call main函数，并在链接脚本中指定开始执行的指令）。因此我们需要在代码中编写panic handler函数以处理出现panic的情况。另外就是作为系统软件，我们需要手动编写代码在启动时将.bss(全局变量)所在的内存段清零，防止后面出现奇怪的错误。当然，我们还需要在汇编代码中分配好栈的大小（由于现在并没有虚拟内存的支持因此只能分配固定大小的栈，我们没有很好的办法防止栈溢出，在完成虚拟内存章节后我们就完全避免这个问题了。）<br>当然我们还需要用宏将我们预编写的汇编语言包含在源代码中这样也生成的二进制中就也会包含我们写的汇编啦(汇编中包含函数入口，分配栈等内容)</p>
<p>ASM和链接器解析</p>
<p>下面是注释后的entry.asm和链接器脚本。asm生成了一些符号然后链接器会把他们按照链接脚本的方式计算出实际地址并翻译为二进制代码。</p>
<p>一个注释后的entry.asm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.section .text.entry       # 定义代码段，.text.entry是一个特殊的段名</span><br><span class="line">.globl _start              # 声明_start符号为全局可见</span><br><span class="line">_start:                    # _start标签，程序入口点</span><br><span class="line">    la sp, boot_stack_top  # 将boot_stack_top的地址加载到栈指针(sp)</span><br><span class="line">    call rust_main         # 调用rust_main函数</span><br><span class="line">    </span><br><span class="line">.section .bss.stack        # 定义未初始化数据段，用于栈</span><br><span class="line">.globl boot_stack_lower_bound  # 声明栈底界限为全局可见</span><br><span class="line">boot_stack_lower_bound:    # 栈底界限标签</span><br><span class="line">    .space 4096 * 16       # 分配16页内存(每页4KB)作为栈空间</span><br><span class="line">.globl boot_stack_top      # 声明栈顶为全局可见</span><br><span class="line">boot_stack_top:            # 栈顶标签</span><br></pre></td></tr></table></figure>
<ul>
<li>boot_stack_lower_bound: 定义了栈底部的标签（地址）</li>
<li>.space 4096 * 16 在这个标签之后预留了 64KB 的内存空间</li>
<li>boot_stack_top: 定义了栈顶部的标签（地址）<br>boot_stack_top 后面什么都没有是因为它标记的是栈空间的结束位置。由于栈是向下增长的，实际的内存布局是这样的：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">高地址 --&gt; boot_stack_top         (栈指针初始位置)</span><br><span class="line">          |</span><br><span class="line">          | 64KB 的栈空间</span><br><span class="line">          |</span><br><span class="line">低地址 --&gt; boot_stack_lower_bound (栈底限制)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>一个注释后的链接器脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv)         &#x2F;&#x2F; 指定输出架构为RISC-V</span><br><span class="line">ENTRY(_start)              &#x2F;&#x2F; 指定程序入口点为_start符号</span><br><span class="line">BASE_ADDRESS &#x3D; 0x80200000; &#x2F;&#x2F; 定义基地址常量，这是RISC-V SBI通常加载内核的地址</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . &#x3D; BASE_ADDRESS;      &#x2F;&#x2F; 将当前位置计数器设为基地址</span><br><span class="line">    skernel &#x3D; .;           &#x2F;&#x2F; 定义skernel符号，表示内核起始地址</span><br><span class="line"></span><br><span class="line">    stext &#x3D; .;             &#x2F;&#x2F; 定义stext符号，表示代码段起始地址</span><br><span class="line">    .text : &#123;              &#x2F;&#x2F; 定义.text段（代码段）</span><br><span class="line">        *(.text.entry)     &#x2F;&#x2F; 首先放入所有.text.entry段（启动代码）</span><br><span class="line">        *(.text .text.*)   &#x2F;&#x2F; 然后放入所有其他.text段（普通代码）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . &#x3D; ALIGN(4K);         &#x2F;&#x2F; 将当前位置按4KB对齐</span><br><span class="line">    etext &#x3D; .;             &#x2F;&#x2F; 定义etext符号，表示代码段结束地址</span><br><span class="line">    srodata &#x3D; .;           &#x2F;&#x2F; 定义srodata符号，表示只读数据段起始地址</span><br><span class="line">    .rodata : &#123;            &#x2F;&#x2F; 定义.rodata段（只读数据段）</span><br><span class="line">        *(.rodata .rodata.*) &#x2F;&#x2F; 放入所有.rodata段（常量等）</span><br><span class="line">        *(.srodata .srodata.*) &#x2F;&#x2F; 放入所有.srodata段（小型只读数据）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . &#x3D; ALIGN(4K);         &#x2F;&#x2F; 将当前位置按4KB对齐</span><br><span class="line">    erodata &#x3D; .;           &#x2F;&#x2F; 定义erodata符号，表示只读数据段结束地址</span><br><span class="line">    sdata &#x3D; .;             &#x2F;&#x2F; 定义sdata符号，表示数据段起始地址</span><br><span class="line">    .data : &#123;              &#x2F;&#x2F; 定义.data段（已初始化数据段）</span><br><span class="line">        *(.data .data.*)   &#x2F;&#x2F; 放入所有.data段（初始化的变量）</span><br><span class="line">        *(.sdata .sdata.*) &#x2F;&#x2F; 放入所有.sdata段（小型数据）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . &#x3D; ALIGN(4K);         &#x2F;&#x2F; 将当前位置按4KB对齐</span><br><span class="line">    edata &#x3D; .;             &#x2F;&#x2F; 定义edata符号，表示数据段结束地址</span><br><span class="line">    .bss : &#123;               &#x2F;&#x2F; 定义.bss段（未初始化数据段）</span><br><span class="line">        *(.bss.stack)      &#x2F;&#x2F; 首先放入.bss.stack段（栈空间）</span><br><span class="line">        sbss &#x3D; .;          &#x2F;&#x2F; 定义sbss符号，表示bss段主体起始地址</span><br><span class="line">        *(.bss .bss.*)     &#x2F;&#x2F; 放入所有.bss段（未初始化变量）</span><br><span class="line">        *(.sbss .sbss.*)   &#x2F;&#x2F; 放入所有.sbss段（小型bss数据）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . &#x3D; ALIGN(4K);         &#x2F;&#x2F; 将当前位置按4KB对齐</span><br><span class="line">    ebss &#x3D; .;              &#x2F;&#x2F; 定义ebss符号，表示bss段结束地址</span><br><span class="line">    ekernel &#x3D; .;           &#x2F;&#x2F; 定义ekernel符号，表示整个内核结束地址</span><br><span class="line"></span><br><span class="line">    &#x2F;DISCARD&#x2F; : &#123;          &#x2F;&#x2F; 定义丢弃段，这些段不会出现在最终二进制文件中</span><br><span class="line">        *(.eh_frame)       &#x2F;&#x2F; 丢弃所有.eh_frame段（异常处理框架，通常不需要）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">关于你提到的 &quot;xx &#x3D; .&quot; 和 &quot;. &#x3D; xx&quot; 语法：</span><br><span class="line"></span><br><span class="line">xx &#x3D; .</span><br><span class="line"></span><br><span class="line">这种形式是在当前位置定义一个符号。</span><br><span class="line">例如 stext &#x3D; . 表示定义符号 stext 指向当前位置计数器的值。</span><br><span class="line">这些符号通常用于在程序中获取段的边界地址。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">. &#x3D; xx</span><br><span class="line"></span><br><span class="line">这种形式是将当前位置计数器设置为某个值。</span><br><span class="line">例如 . &#x3D; BASE_ADDRESS 将位置计数器设为基地址。</span><br><span class="line">. &#x3D; ALIGN(4K) 将位置计数器向上对齐到4KB的整数倍。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">链接器脚本的工作方式是按顺序处理各个段，并且使用一个&quot;位置计数器&quot;（用 . 表示）来跟踪当前的地址。每定义一个段，这个计数器就会增加该段的大小。</span><br><span class="line">通过这种方式，链接器能够：</span><br><span class="line"></span><br><span class="line">计算每个段和符号的最终内存地址</span><br><span class="line">调整代码中的引用，使它们指向正确的地址</span><br><span class="line">生成一个内存布局明确的最终二进制文件</span><br></pre></td></tr></table></figure>

<h2 id="Chapter-2-批处理系统"><a href="#Chapter-2-批处理系统" class="headerlink" title="Chapter 2 批处理系统"></a>Chapter 2 批处理系统</h2><p>Ref: <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/index.html" target="_blank" rel="noopener">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/index.html</a><br>rCore的第二章主要内容是如何实现系统调用。这一章涉及的具体“知识”非常少，大部分是工程细节。系统调用和函数调用非常相似，为了防止寄存器被嵌套函数执行时修改，都需要在调用前保存好上下文并在返回时恢复。与编译原理中哪些prolog和epilog完全一致。<br>唯二的区别在于，首先。操作系统需要保存所有的通用寄存器（因为不再有convention保护），以及重要的CSR（控制寄存器）。CSR是用户态程序无需关心的。这些寄存器包括保存了CPU当前特权级的sstatus ，trap返回后继续执行的地址sepc trap的原因以及附加信息scause/stval 等等。其次，处于安全考虑，操作系统需要维护自己的栈，而不能和用户态程序一样单纯继续向下开辟栈。因此我们可以利用RISCV中提供的额外寄存器sscratch 来保存内核栈的地址。这样当trap发生时，我们就可以从sscratch 中找到内核栈的地址并开始处理了。<br>需要注意的是，由于目前为止所有操作都是在物理地址上发生的。所以实际上应用程序有能力访问所有内存的并找到操作系统的内核栈，目前我们的操作系统并没有实现任何内核态和用户态的隔离。这一点可以通过x86架构提供的段实现，RISCV有没有类似功能尚不清楚。当然，这个问题会在我们实现虚拟内存后完全解决。<br>祝自己明天开始写第一个lab顺利！</p>
<h2 id="Chapter-3-多道程序与分时多任务"><a href="#Chapter-3-多道程序与分时多任务" class="headerlink" title="Chapter 3 多道程序与分时多任务"></a>Chapter 3 多道程序与分时多任务</h2><p>Ref:<a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/index.html" target="_blank" rel="noopener">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/index.html</a><br>rCore的第三章将操作系统的调度能力进一步拓展，在chapter 2中，我们的操作系统只能按照设定好的顺序逐个运行程序。而Chapter 3加入了抢占机制，使操作系统能够交替运行不同程序。极大的改善了程序的交互体验。<br>实现分时共享系统的核心是timer的加入。timer是一个来自硬件的中断发生器，会不断的向操作系统发出中断。每当中断来临时，操作系统就会接管节点，并决定是否要切换到另一个应用程序执行。切换的步骤与第二章中的系统调用是非常相似的。因为都是“打断”当前应用程序的执行并在稍后回复。因此需要保存应用运行的上下文。<br>在这一章中，应用程序有了task的抽象。并通过task数据结构被操作系统调度(突然理解了为什么linux中的进程管理块名叫task哈哈哈)<br>这一章的作业实现trace系统调用，还是比较简单的，希望之后一切顺利。容易错的点是题目实际要求的是分别统计每个应用的系统调用次数。因此需要简历一个二维数组。另外如果试图将数组放到更内层的TaskControlBlock 而不是TaskManager 会出现奇怪的内核崩溃bug。怀疑是因为TaskControlBlock 在内存中位置和长度都固定锁导致的.所以最终还是把二维数组放到了TaskManager 中</p>
<h2 id="Chapter-4-地址空间"><a href="#Chapter-4-地址空间" class="headerlink" title="Chapter 4 地址空间"></a>Chapter 4 地址空间</h2><p>Ref:<a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/index.html" target="_blank" rel="noopener">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/index.html</a><br>这一章中终于实现了虚拟内存。我们的程序可以拥有单独的地址空间而不是时刻在意自己具体的内存位置了。虚拟内存的实现是通过名为MemorySet 和MemoryMap 的数据结构实现的，这点和Linux中的虚拟内存管理非常一致。<br>虚拟内存管理通过硬件上的MMU自动实现虚拟地址到物理地址的翻译。只需要将页表的root page放置在特定的寄存器中就可以让硬件实现正确寻址。<br>加入虚拟内存让内核迎来了一次比较大的重构。因为我们之前最重要的管理机制：系统调用和程序切换锁保存的上下文会发生不同。这里涉及到很多tricky的问题，比如说开启虚拟内存后，在我进入内核的地址空间后，需要通过应用态的页表手动找到需要保存的上下文。还有由于地址空间不同，在陷入内核态之前需要通过一个特定的相同的跳板页来实现丝滑switch。这些设计上的细节是之前理论上学习操作系统时根本没有想过的。<br>关于这一节的实验没想到最困难的并不是mmap和unmap，而是port sys_trace函数。再试图往对应地址写入是，我把PPN转usize再加上offset结果发现一直不对。然后发现PPN居然并不是Physical Address但是后面用0 padding，它就单纯的是个物理页号。需要先左移PAGE_SIZE再加offset才是对应的physical address。</p>
<h2 id="Chapter-5-进程"><a href="#Chapter-5-进程" class="headerlink" title="Chapter 5 进程"></a>Chapter 5 进程</h2><p>Ref: <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter5/5exercise.html" target="_blank" rel="noopener">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter5/5exercise.html</a><br>这一节终于引入了进程的概念。它其实只是之前四章内容的更上一层抽象。进程的抽象让操作系统可以实现更加丰富的语义。比如更只能的进程调度，通过fork(), exec()运行新的程序。以及在这一章，我们终于有了shell！操作系统更像一个真正的操作系统了。<br>这一章具体的内容不多，大部分为有机的组合前四章的内容实现进程的概念。以及增加了进程管理的相关细节。比如如何启动第一个进程，进程退出后如何回收等等。<br>本章的实验倒是十分简单， spawn系统调用就是fork+exec拼一拼，只不过把复制memoryset的部分去掉。而stride调度器也只是在manager结构中统计一下步长和priority并根据它们调度。只要找到了对应的数据结构实现起来非常简单。</p>
<h2 id="Chapter-6-文件系统"><a href="#Chapter-6-文件系统" class="headerlink" title="Chapter 6 文件系统"></a>Chapter 6 文件系统</h2><p>Ref: <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter6/index.html" target="_blank" rel="noopener">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter6/index.html</a><br>文件系统！终于可以把程序存在块设备上而不是呆在内存里了！因为在ECE566课上已经学过一遍了所以基本没有什么新知识。但是能看到具体的实现还是学到了很多细节。比如说具体如何和驱动程序沟通。但是由于disk的驱动程序已经做好了抽象所以实际上我们只需要实现对应的接口就可以了。<br>我在实验的第一版实现中犯了蠢在实现hardLink的时候给每个hardlink都创建了一个新的inode并且给inode增加一个新的type hardlink，然后修改read和write的逻辑。加一层indirection找到linkto的inode执行实际的读写<br>后面发现根本没必要啊！只需要在文件夹中的directory entry中将文件名link到对应的inode即可。另外一个奇怪的bug是如果在DiskNode加入太多的字段会触发奇怪的虚拟内存相关报错LoadPageError。而这个behavior在不同机器上跑的出现还不一样，非常随机。不知道为什么会这样，怀疑是加入太多字段会影响数据结构在内存中的排布？由于实在是太难debug了所以最终并没有发现根因、这个bug是所有rcore实验中困扰我最多的实验，干了一整个通宵，十分痛苦。<br>另一点是因为引入了stdout和stdin，在spawn创建新的进程的时候需要记得初始化stdout，否则会出现测试程序打印不出来内容的窘境。</p>
<h2 id="Chapter-7-进程间通信"><a href="#Chapter-7-进程间通信" class="headerlink" title="Chapter 7 进程间通信"></a>Chapter 7 进程间通信</h2><p>Ref: <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter7/index.html" target="_blank" rel="noopener">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter7/index.html</a><br>之前一直觉得linux语法很难理解，， 总觉得程序是一步一步执行的。 比如a|b 就是先运行a再把输出传给b 但看到有一些命令就晕了比如为什么有的命令可以cmd xx &gt; yy &lt;&lt; zz 难道先执行xx和yy？ 看这一章惊觉shell命令是一起被处理而不是一步一步执行的，恍然大悟！<br>具体内容倒没有很多，我们只需要给不同的东西实现file trait就可以在进程中使用文件描述符等来管理它，再在运行时动态分配到stdout 特有的write函数中去打印到屏幕上。<br>io重定向也是类似的原理，通过一些操作读取第一个程序的stdout然后作为输入交给第二个程序，也就实现了重定向了。<br>进程间通信同理，我们给进程间通信的ringbuffer也实现read write等方法，在调用时实际写入一个ringbuffer而非实际文件即可。</p>
<h2 id="Chapter-8-并发"><a href="#Chapter-8-并发" class="headerlink" title="Chapter 8 并发"></a>Chapter 8 并发</h2><p>这一节大部分内容真是学了无数遍了，OSTEP学了一遍，ECE650学了一遍，这次又学了一遍。锁，信号量，条件变量着实是滚瓜烂熟了。倒是线程管理的部分非常有趣。这一章把rcore变成了类似linux的方式，线程是基本的调度单位，进程仅仅维护fd_table, memoryset等进程共享资源。为了添加线程的支持，进程需要维护好每个线程的上下文和运行栈，线程的栈因为共享地址空间所以会被放置在特定的内存位置统一管理。在切换的时候与进程调度基本一致。<br>如果需要跨进程切换线程switch函数会负责切换地址空间，来保证线程的顺利运行。<br>这一章的lab是实现银行家算法。算是个蛮有意思的题目。但是感觉实现本身和OS的线程调度机制没有太大的关系，而且由于类似算法的时间复杂度实际操作系统中应该不会包含类似的算法。如果题目可以和OS本身更加相关就好了</p>
<h1 id="arceos部分"><a href="#arceos部分" class="headerlink" title="arceos部分"></a>arceos部分</h1><h2 id="Lab1-Print"><a href="#Lab1-Print" class="headerlink" title="Lab1 Print"></a>Lab1 Print</h2><p>第一个lab非常简单，只需要在println宏中加入riscv对应颜色的转义字符即可。注意要在打印后使用reset转义字符，不然后面所有的输出就都变颜色了。<br>下面是一些常用的转义字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const ANSI_CODES: &amp;[(&amp;str, &amp;str)] &#x3D; &amp;[</span><br><span class="line">    &#x2F;&#x2F; 基本颜色</span><br><span class="line">    (&quot;BLACK&quot;, &quot;\x1b[30m&quot;),</span><br><span class="line">    (&quot;RED&quot;, &quot;\x1b[31m&quot;),</span><br><span class="line">    (&quot;GREEN&quot;, &quot;\x1b[32m&quot;),</span><br><span class="line">    (&quot;YELLOW&quot;, &quot;\x1b[33m&quot;),</span><br><span class="line">    (&quot;BLUE&quot;, &quot;\x1b[34m&quot;),</span><br><span class="line">    (&quot;MAGENTA&quot;, &quot;\x1b[35m&quot;),</span><br><span class="line">    (&quot;CYAN&quot;, &quot;\x1b[36m&quot;),</span><br><span class="line">    (&quot;WHITE&quot;, &quot;\x1b[37m&quot;),</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 粗体颜色</span><br><span class="line">    (&quot;BRIGHT_BLACK&quot;, &quot;\x1b[90m&quot;),</span><br><span class="line">    (&quot;BRIGHT_RED&quot;, &quot;\x1b[91m&quot;),</span><br><span class="line">    (&quot;BRIGHT_GREEN&quot;, &quot;\x1b[92m&quot;),</span><br><span class="line">    (&quot;BRIGHT_YELLOW&quot;, &quot;\x1b[93m&quot;),</span><br><span class="line">    (&quot;BRIGHT_BLUE&quot;, &quot;\x1b[94m&quot;),</span><br><span class="line">    (&quot;BRIGHT_MAGENTA&quot;, &quot;\x1b[95m&quot;),</span><br><span class="line">    (&quot;BRIGHT_CYAN&quot;, &quot;\x1b[96m&quot;),</span><br><span class="line">    (&quot;BRIGHT_WHITE&quot;, &quot;\x1b[97m&quot;),</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 背景色</span><br><span class="line">    (&quot;BG_BLACK&quot;, &quot;\x1b[40m&quot;),</span><br><span class="line">    (&quot;BG_RED&quot;, &quot;\x1b[41m&quot;),</span><br><span class="line">    &#x2F;&#x2F; ... 其他背景色</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 样式</span><br><span class="line">    (&quot;BOLD&quot;, &quot;\x1b[1m&quot;),</span><br><span class="line">    (&quot;UNDERLINE&quot;, &quot;\x1b[4m&quot;),</span><br><span class="line">    (&quot;REVERSED&quot;, &quot;\x1b[7m&quot;),</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 控制</span><br><span class="line">    (&quot;RESET&quot;, &quot;\x1b[0m&quot;),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h2 id="Lab-2-Hashmap"><a href="#Lab-2-Hashmap" class="headerlink" title="Lab 2 Hashmap"></a>Lab 2 Hashmap</h2><p>由于测例非常简单，所以偷了一下懒，用嵌套vector实现的hashmap，甚至没有实现resize(非常懒了！)<br>这一个lab的难度也不在写代码上，重点在于理解ArceOS的代码结构，然后把HashMap的代码糊上即可。<br>实验中遇到了两个小坑，</p>
<ol>
<li>因为在std的lib.rs 中已经引用了alloc中的collections，因此我们的hashmap不能在collections里面，必须命名成别的，我命名成了axcollections。exercise中的用户态程序也要同步更改。</li>
<li>我的hashmap实现中用到了vector，因此需要用到globalallocator调用alloc动态分配内存。但是在第一个测试print_with_color编译选项中没有编译allocator。因此需要在axstd中我们的collections前面加上编译选项的宏，这样就编译第一个测试才不会报错。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#[cfg(feature &#x3D; &quot;alloc&quot;)]</span><br><span class="line">pub mod axcollections;</span><br></pre></td></tr></table></figure>
目前对ArceOS有了一个比较初步的理解</li>
<li>axlibc和axstd对应linux中的glibc和std。是用户态程序，会通过系统api(位于arceos/api )和os通信（而不是syscall？）</li>
<li>OS的核心代码在modules中，包括了硬件抽象层HAL，内存管理MM，网络，进程管理等等都以模块化管理。这次作业比较相关的动态内存分配GlobalAllocator实现在了在axalloc中<br>还有一个意外得到知识是哈希函数本身<br>这次第一次用到Rust的Hash trait。 这个trait提供hash函数，接收一个实现了Hasher trait的state<br>为什么需要一个带state的Hasher而不能直接Hash返回一组字节呢？<br>因为希望灵活的处理哈希算法，并且比如你有多个字段或者字段内部有嵌套的字段它们都需要被被哈希，这个时候hash(hasher)可以帮助你抽象掉冗杂的细节，实现增量哈希。<br>ps: 在哈希或密码学最忌讳灵机一动,我一开始想着把多个字段的哈希值直接异或也可以得到一个值呀，但这样的算法会面临严重的碰撞问题，比如(a,b,c)和(c,b,a)会得到相同的哈希值，会对哈希表的性能产生很大的影响。</li>
</ol>
<h2 id="Lab-3-Bump-Allocator"><a href="#Lab-3-Bump-Allocator" class="headerlink" title="Lab 3 Bump Allocator"></a>Lab 3 Bump Allocator</h2><p>这次的实验是实现一个Global Allocator。这是我一直非常好奇的一个部分。在rcore实验，rcore已经提供了一个实现好的buddy allocator。这次终于有机会自己实现了。<br>研读代码后发现，Global Allocator虽然名义上管理memory的allocation，但它实际上并不操作任何memory。它只是个“数字管理器”，记录哪些块被分出去，哪些块没有。实际上也没有任何措施来保证未分配的块不能被访问——这个功能是由Page Table通过页表项中合理的bit设定通过硬件保证的。<br>我在这里意外的发现Slab Allocator的实现和之前在CSAPP学习到的malloc实现惊人的相似。都是通过二的幂次管理多重链表来平衡分配内存的时间复杂度和额外空间占用。仔细想来也非常合理。global allocator和malloc实际上不涉及任何用户态和内核态的内容。它们本质上都是管理一段连续的数组，然后通过一定的算法尽量保证这个数组被高效利用。那么最终收敛到相似的设计就完全可以理解了。<br>本身的代码非常简单，略过不提。</p>
<h2 id="Lab-4-File-Rename"><a href="#Lab-4-File-Rename" class="headerlink" title="Lab 4 File Rename"></a>Lab 4 File Rename</h2><p>这次的实验是实现file rename操作。我照着ppt里的要求实现了结果发现ppt的作业和实际跑的test并不一样（尴尬。<br>由于myfilesystem的大部分实现是调用的现有库，无法更改。我的move实现本质上并没有操作文件系统，而是单纯的调用操作系统的API把一个文件内容读出来，然后创建并写入新文件。算是取巧过去了。<br>如果需要在文件系统层级实现rename，无需如此笨拙，只需更改directory node中对应的name，将name复制到new path 的directory node中即可。根本无需访问inode进行整个文件的读写</p>
<h2 id="Lab-5-sys-mmap"><a href="#Lab-5-sys-mmap" class="headerlink" title="Lab 5 sys_mmap"></a>Lab 5 sys_mmap</h2><p>这次实验是给教学用的arceos添加mmap操作。之前并没怎么使用过linux的mmap映射文件的功能。恰好借助这个机会补充一下。map文件到内存听上去很高大上，其实仔细想来只需要做三件事。</p>
<ol>
<li>根据用户的参数申请一段连续内存</li>
<li>将文件内容读入内存并写到对应的内存上</li>
<li>当对应内存写入时，标记脏页并由内核线程写回磁盘(类似于文件写)<br>在这次lab中，由于测例比较简单并没有实现3.<br>1和2的实现方法需要找到陷入当前trap的进程的currentTask控制块，然后在它的地址空间中预定一块内存。然后调用fs的api读取文件，再将文件写入对应的内存中。更理想的实现可能为修改fs的接口，让文件读取可以直接读取到一段指定内存，这可以减少一次内存的复制操作。<br>实现3的方法应该是借助MemoryArea的分类进行。比如文件申请的内存为FileBlockMemoryArea，有一个异步线程会定期被唤醒去把脏页写回block。所以对应到mmap当mmap需求的是map文件时，在map.alloc这个调用中需要指定类型为FileBlock。对于普通的操作则申请匿名内存，不需要异步线程进行检查</li>
</ol>
<h2 id="Lab6-simple-hv"><a href="#Lab6-simple-hv" class="headerlink" title="Lab6 simple_hv"></a>Lab6 simple_hv</h2><p>这一个lab给我们展示了一个“最小hypervisor”的实现。类似于rcore Lab中的syscall实验。在rcore和arceos阶段研读过操作系统的代码后，实际上Hypervisor的运行方式并不难以想象。操作系统的目的是，安全，高效的同时运行多个程序。为了达成这个目的主要实现了抢占式调度，地址空间，以及特权级机制。Hypervisor同理，它要安全，高效的运行多个操作系统。因此也可以通过类似的方法，比如抢占式调度（或者干脆利用多核实现真并行调度，如教学代码所示），对于操作系统来说也需要“虚拟物理地址”，相当于一个vm级别的地址空间。另外，OS不再直接管理外设，也不能直接控制硬件，所以对于一些可能影响硬件的”危险操作“我们再进行一次特权级的隔离。让os通过与syscall类似的hypercall把这些操作的权利交给hypervisor定夺。<br>仔细想想，实际上type-II hypervisor也几乎可以通过类似的机制实现。这一套并不局限于直接运行在硬件上的Type-I Hypervisor，只要硬件提供特权级的隔离这一套可以轻易实现。硬件支持真是个好东西。想到了当时读Xen的论文，通过Para Virtualization重量级实现hypervisor那种巨大的工程量，再到现在各个处理器指令集都支持虚拟化扩展，可以通过几百行代码实现一个简单虚拟机。也算是软件系统的需求促进的硬件发展的一个样例了。<br>时过境迁，前两年Timothy在OSDI疾呼研究者应该回归OS的本质做hardware-software co-design。现在新硬件层出不穷，硬件加速器，智能网卡，TEE，还有RDMA，CXL一堆新名词。好像“攻守之势异也”，变成了硬件推动OS进步了。面对着越来越多的外设和越来越专业化的使用场景，操作系统研究者的未来又在何方呢？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/30/rcore-camp-2025S-stage1&2-%E9%A2%9C%E7%86%99%E7%82%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/30/rcore-camp-2025S-stage1&2-%E9%A2%9C%E7%86%99%E7%82%86/" class="post-title-link" itemprop="url">rcore-camp-2025S-stage1&2-颜熙炆.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-30 17:03:26" itemprop="dateCreated datePublished" datetime="2025-04-30T17:03:26+00:00">2025-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-06 06:28:39" itemprop="dateModified" datetime="2025-05-06T06:28:39+00:00">2025-05-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h1><p>本博客作为开源操作系统训练营2025S的1、2阶段学习记录，简单总结了在这两个阶段的学习和coding。留作纪念，也希望能够帮助到大家。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/2025/04/30/rcore-camp-2025S-stage1&2-%E9%A2%9C%E7%86%99%E7%82%86/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/28/OrangeQi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/28/OrangeQi/" class="post-title-link" itemprop="url">OrangeQi</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-28 02:39:23" itemprop="dateCreated datePublished" datetime="2025-04-28T02:39:23+00:00">2025-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-06 06:28:39" itemprop="dateModified" datetime="2025-05-06T06:28:39+00:00">2025-05-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前对操作系统有一定理论基础，rcore 和 arceos 项目对我最大的挑战主要包括：</p>
<ol>
<li>risc-v 体系结构的知识，尤其是特权架构。这对理解 trap、context_switch、地址空间相关的代码极其重要。</li>
<li>arceos 项目的组织构建。最底层是 axhal，抽象了硬件架构和运行平台，往上是各个 module 例如 axtask 等，再向上是 axapi 乃至 ulib。这种组件化的设计思想充分利用的 rust 语言的优势，极大方便构建。</li>
</ol>
<p>unikernel 架构是没有特权级切换的，应用程序也运行在 s 态。刚开始没有仔细理解 ppt，给我造成了挺大的困扰。</p>
<p>hashmap 的实验我并没有自己手写代码，而是直接引入了 hashbrown 库。但手撕一下代码应该能更加锻炼能力。</p>
<p>此外，hypervisor 给我带来了挺大的困难，参考其他同学的经验我才得以通过。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap1/" class="post-title-link" itemprop="url">rcore-handnote-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-06 06:28:39" itemprop="dateModified" datetime="2025-05-06T06:28:39+00:00">2025-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><h3 id="Execution-Environment"><a href="#Execution-Environment" class="headerlink" title="Execution Environment"></a>Execution Environment</h3><p><img src="/blog/.io//assets/lab1-1.png" alt="Execution Environment"></p>
<p>The execution environment is defined by the <strong>Target Triplet</strong>, which specifies the platform, CPU architecture, and library required for the build. For example: <code>x86_64-unknown-linux-gnu</code>.</p>
<p><strong>Components of the Target Triplet:</strong></p>
<ul>
<li><strong>Platform</strong>: The specific operating system or runtime environment.</li>
<li><strong>CPU Architecture</strong>: The underlying hardware architecture (e.g., x86_64, ARM).</li>
<li><strong>Library</strong>: The standard library or runtime support required.</li>
</ul>
<p>If the target platform contains no <code>std</code> or any support syscall, such platform called <strong>bare-metal</strong>, <code>Rust</code> contains a <code>core</code> lib independent of any platform support.</p>
<p>If we change <code>.cargo/config</code> s.t.:</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># os/.cargo/config</span></span><br><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="attr">target</span> = <span class="string">"riscv64gc-unknown-none-elf"</span></span><br></pre></td></tr></table></figure>
<p>it called <strong>cross compile</strong> because the running platform is different form execution platform.</p>
<h4 id="No-Std-and-No-Main"><a href="#No-Std-and-No-Main" class="headerlink" title="No Std and No Main"></a><em>No Std</em> and <em>No Main</em></h4><p>The basic functionality provided by <code>std</code> and <code>start</code> semantic is <code>panic_handler</code> and <code>main</code> entry. </p>
<p>To toggle it off with:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br></pre></td></tr></table></figure>

<h4 id="RISCV"><a href="#RISCV" class="headerlink" title="RISCV"></a>RISCV</h4><p>As for riscv, thing will be tough in here, we need to complete our own entry point, exit, and basic functionality like <code>print/println</code>. </p>
<p>First, we need to define <code>linker</code> and <code>entry</code> for stack allocation.</p>
<p>Linker:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># os/src/linker.ld</span></span><br><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(_start) <span class="comment"># entry point</span></span><br><span class="line">BASE_ADDRESS = 0x80200000; <span class="comment"># base addr for entry</span></span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Stack Space:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># os/src/entry.asm</span></span><br><span class="line">    .section .text.entry</span><br><span class="line">    .globl _start</span><br><span class="line">_start:</span><br><span class="line">    la sp, boot_stack_top</span><br><span class="line">    call rust_main <span class="comment"># call rust_main function as entry </span></span><br><span class="line"></span><br><span class="line">    .section .bss.stack</span><br><span class="line">    .globl boot_stack_lower_bound</span><br><span class="line">boot_stack_lower_bound:</span><br><span class="line">    .space 4096 * 16</span><br><span class="line">    .globl boot_stack_top</span><br><span class="line">boot_stack_top:</span><br></pre></td></tr></table></figure>

<p>For riscv, we need to call <code>RustSBI</code>(a underlying specification for rust in riscv).</p>
<p>After implement <code>sbi_call</code>, we could construct <code>put_char</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SBI_CONSOLE_PUTCHAR: <span class="built_in">usize</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sbi_call</span></span>(...) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">console_putchar</span></span>(c:<span class="built_in">usize</span>) &#123;</span><br><span class="line">	sbi_call(SBI_CONSOLE_PUTCHAR,c,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With a formal interface for <code>write</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stdout</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Write <span class="keyword">for</span> Stdout &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_str</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="built_in">str</span>) -&gt; fmt::<span class="built_in">Result</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s.chars() &#123;</span><br><span class="line">            console_putchar(c <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>(args: fmt::Arguments) &#123;</span><br><span class="line">    Stdout.write_fmt(args).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we construct basic functionality in <code>println</code>, you could also handle <code>panic_handler</code> and others…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap3/" class="post-title-link" itemprop="url">rcore-handnote-3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-06 06:28:39" itemprop="dateModified" datetime="2025-05-06T06:28:39+00:00">2025-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>We need to place multiple app to multiple memory address to run app in cycle. Rather run once and clear for next.</p>
<p>First We want to place each app to each isolated addr, due to our kernel restriction, we need to load it with <code>build.py</code>.</p>
<hr>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>Task: a workflow process</p>
<p>Define every time slice of <strong>Task</strong> as <strong>Task Slice</strong></p>
<p>Define the switch between app as <strong>Task switching</strong></p>
<p>We need to store <strong>Task Context</strong></p>
<p>Design:<br><img src="/blog/.io//assets/Lab3-1.png" alt="switch"></p>
<p>We will store these register in ctx:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/context.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span></span> &#123;</span><br><span class="line">    ra: <span class="built_in">usize</span>,</span><br><span class="line">    sp: <span class="built_in">usize</span>,</span><br><span class="line">    s: [<span class="built_in">usize</span>; <span class="number">12</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_SN n</span><br><span class="line">    sd s\n, (\n+2)*8(a0)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_SN n</span><br><span class="line">    ld s\n, (\n+2)*8(a1)</span><br><span class="line">.endm</span><br><span class="line">    .section .text</span><br><span class="line">    .globl __switch</span><br><span class="line">__switch:</span><br><span class="line">...</span><br><span class="line"># logic by store previous context and take out the new one to current register</span><br></pre></td></tr></table></figure>

<p>Expose to Rust</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/switch.rs</span></span><br><span class="line"></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">"switch.S"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::TaskContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">__switch</span></span>(</span><br><span class="line">        current_task_cx_ptr: *<span class="keyword">mut</span> TaskContext,</span><br><span class="line">        next_task_cx_ptr: *<span class="keyword">const</span> TaskContext</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We will design <code>TaskManager</code>:</p>
<ul>
<li>Store each App state array and current running app.</li>
<li>each state store <code>TaskContext</code> and <code>TaskState</code> for running or exited etc…</li>
<li>Init and ready by store the <code>__restore</code> ctx to <code>TaskContext</code></li>
<li>Run for switch cx if needed.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> current_task_cx_ptr = &amp;<span class="keyword">mut</span> inner.tasks[current].task_cx <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext;</span><br><span class="line"><span class="keyword">let</span> next_task_cx_ptr = &amp;inner.tasks[next].task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line"><span class="built_in">drop</span>(inner);</span><br><span class="line"><span class="comment">// before this, we should drop local variables that must be dropped manually</span></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">	__switch(</span><br><span class="line">		current_task_cx_ptr,</span><br><span class="line">		next_task_cx_ptr,</span><br><span class="line">	);</span><br><span class="line">&#125;rust</span><br></pre></td></tr></table></figure>


<h3 id="Dispatch-Design"><a href="#Dispatch-Design" class="headerlink" title="Dispatch Design"></a>Dispatch Design</h3><h4 id="Collaboration"><a href="#Collaboration" class="headerlink" title="Collaboration"></a>Collaboration</h4><p>Manually design interface <code>yield</code> for App to use</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_yield</span></span>() -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    syscall(SYSCALL_YIELD, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">yield_</span></span>() -&gt; <span class="built_in">isize</span> &#123; sys_yield() &#125;</span><br></pre></td></tr></table></figure>

<p>But it can be inefficient for some case that app already done its work but reluctant to exit.</p>
<h4 id="Preemptive"><a href="#Preemptive" class="headerlink" title="Preemptive"></a>Preemptive</h4><p>We will design interrupt clock in a fixed time bound to force switch between app.</p>
<ul>
<li>Set timer design and get time</li>
<li>Set timer for trigger</li>
<li>enable timer and handle the interrupt cause of Timer in <code>ecall</code></li>
</ul>
<p>You should know this as a pre-knowledge:</p>
<p><img src="/blog/.io//assets/Lab3-2.png" alt></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SBI_SET_TIMER: <span class="built_in">usize</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_timer</span></span>(timer: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    sbi_call(SBI_SET_TIMER, timer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/timer.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::config::CLOCK_FREQ;</span><br><span class="line"><span class="keyword">const</span> TICKS_PER_SEC: <span class="built_in">usize</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_next_trigger</span></span>() &#123;</span><br><span class="line">    set_timer(get_time() + CLOCK_FREQ / TICKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/trap/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> scause.cause() &#123;</span><br><span class="line">    Trap::Interrupt(Interrupt::SupervisorTimer) =&gt; &#123;</span><br><span class="line">        set_next_trigger();</span><br><span class="line">        suspend_current_and_run_next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enable supervisor clock</span></span><br><span class="line"><span class="comment">// os/src/trap/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> riscv::register::sie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">enable_timer_interrupt</span></span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; sie::set_stimer(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap2/" class="post-title-link" itemprop="url">rcore-handnote-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-06 06:28:39" itemprop="dateModified" datetime="2025-05-06T06:28:39+00:00">2025-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p><img src="/blog/.io//assets/Lab2-1.png" alt="Introduction"></p>
<p>It corresponds to <code>riscv</code>:</p>
<ul>
<li>Privilege for <code>S</code>(guaranteed by <code>Supervisor Execution Environment</code> of <code>RustSBI</code>)</li>
<li>User for <code>U</code>(constructed in current chapter as <code>Application Execution Environment</code>)</li>
</ul>
<p>Reason:</p>
<ul>
<li>Safety(Prevent app from accessing kernel)</li>
<li>Recoverable</li>
</ul>
<p>Workflow:</p>
<ul>
<li>Start application and user-mode context</li>
<li><strong>Trap</strong>(Called by system level) to handle system<ul>
<li>Goes wrong! Kill it!</li>
<li>Finish! Next!</li>
</ul>
</li>
<li><strong>Restore</strong> to user-mode context</li>
</ul>
<p><code>riscv</code> designs following <code>CSR</code>(Control and Status Register) to handle this:</p>
<h3 id="CSR"><a href="#CSR" class="headerlink" title="CSR"></a>CSR</h3><p><img src="/blog/.io//assets/Lab2-2.png" alt="CSR"></p>
<p>Begin <strong>Trap</strong>:</p>
<ul>
<li>sstatus: <code>SPP</code> seg to the current level of CPU.</li>
<li>sepc: next addr after Trap finished.</li>
<li>scause/stval: Trap cause and additional info.</li>
<li>stvec: storage of entry addr of Trap</li>
</ul>
<blockquote>
<p><strong>stvec</strong> is a 64-bit CSR, with:</p>
<ul>
<li>MODE(Direct/Vectored) <code>[1:0]</code>(read from right to left): 2-bits</li>
<li>BASE <code>[63:2]</code>: 62-bits</li>
</ul>
</blockquote>
<p>finally, it will return by instruction <code>sret</code> which will change level and jump by <code>sepc</code>.</p>
<h3 id="Construct-Trap"><a href="#Construct-Trap" class="headerlink" title="Construct Trap"></a>Construct Trap</h3><p>Design:</p>
<ul>
<li>General register will be shared by U-level and S-level.</li>
<li>Maintain a reasonable state of <code>CSR</code>.</li>
<li>Separate workflow of U-level and S-level by stack</li>
</ul>
<p>Construct:</p>
<ul>
<li>build <code>KernelStack</code> and <code>UserStack</code> for separation</li>
<li>in <code>KernelStack</code>, we store <code>TrapContext</code> in it, by asm and rust to control dispatch and handle, then store the code to <code>stvec</code> as the entry of Trap.</li>
<li>restore register for <code>UserStack</code> by push a new context refer to <code>UserStack</code>.</li>
</ul>
<p>build stack and push context:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack struct ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// buttom to top</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_sp</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.data.as_ptr() <span class="keyword">as</span> <span class="built_in">usize</span> + KERNEL_STACK_SIZE</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">push_context</span></span>(&amp;<span class="keyword">self</span>, cx: TrapContext) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">let</span> cx_ptr = (<span class="keyword">self</span>.get_sp() - core::mem::size_of::&lt;TrapContext&gt;()) <span class="keyword">as</span> *<span class="keyword">mut</span> TrapContext;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *cx_ptr = cx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; cx_ptr.as_mut().unwrap() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/trap/context.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrapContext</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> x: [<span class="built_in">usize</span>; <span class="number">32</span>], <span class="comment">// General register</span></span><br><span class="line">    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line">    <span class="keyword">pub</span> sepc: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// set stack pointer to x_2 reg (sp)</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_sp</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, sp: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.x[<span class="number">2</span>] = sp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// init app context</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">app_init_context</span></span>(entry: <span class="built_in">usize</span>, sp: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> sstatus = sstatus::read(); <span class="comment">// CSR sstatus</span></span><br><span class="line">    sstatus.set_spp(SPP::User); <span class="comment">//previous privilege mode: user mode</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> cx = <span class="keyword">Self</span> &#123;</span><br><span class="line">        x: [<span class="number">0</span>; <span class="number">32</span>],</span><br><span class="line">        sstatus,</span><br><span class="line">        sepc: entry, <span class="comment">// entry point of app</span></span><br><span class="line">    &#125;;</span><br><span class="line">    cx.set_sp(sp); <span class="comment">// app's user stack pointer</span></span><br><span class="line">    cx <span class="comment">// return initial Trap Context of app</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We will design <code>__alltrap</code> and <code>__restore</code> for operation by asm and part of rust:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_GP n</span><br><span class="line">    sd x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_GP n</span><br><span class="line">    ld x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">.align_2</span><br><span class="line">__alltraps:</span><br><span class="line">    ...</span><br><span class="line"># set input argument of trap_handler(cx: &amp;mut TrapContext)</span><br><span class="line">    mv a0, sp # sp is point to TrapContext in kernel stack</span><br><span class="line">    call trap_handler # (&amp;mut TrapContext)</span><br><span class="line"></span><br><span class="line">--restore:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>To handle Trap context, we will use <code>riscv</code> lib:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/Cargo.toml</span></span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">riscv = &#123; git = <span class="string">"https://github.com/rcore-os/riscv"</span>, features = [<span class="string">"inline-asm"</span>] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/trap/mod.rs</span></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">"trap.S"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> &#123; <span class="function"><span class="keyword">fn</span> <span class="title">__alltraps</span></span>(); &#125;</span><br><span class="line">    <span class="comment">// write to stvec</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        stvec::write(__alltraps <span class="keyword">as</span> <span class="built_in">usize</span>, TrapMode::Direct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">trap_handler</span></span>(cx: &amp;<span class="keyword">mut</span> TrapContext) -&gt; &amp;<span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>restore operation:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123; <span class="function"><span class="keyword">fn</span> <span class="title">__restore</span></span>(cx_addr: <span class="built_in">usize</span>); &#125;</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    __restore(KERNEL_STACK.push_context(</span><br><span class="line">        TrapContext::app_init_context(APP_BASE_ADDRESS, USER_STACK.get_sp())</span><br><span class="line"><span class="comment">// This context store the ptr to UserStack for restoration</span></span><br><span class="line">    ) <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Construct-User-App"><a href="#Construct-User-App" class="headerlink" title="Construct User App"></a>Construct User App</h3><ul>
<li>Link app binary to kernel with specify memory layout</li>
<li>Read the layout, use <code>AppManager</code> to maintain and store</li>
<li>Load app from memory layout, copy consecutively to <code>APP_BASE_ADDRESS</code>(Currently we have no ability to dynamically read address)</li>
<li>AppManager will run each app</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># os&#x2F;src&#x2F;link_app.S</span><br><span class="line"></span><br><span class="line">    .align 3</span><br><span class="line">    .section .data</span><br><span class="line">    .global _num_app # read from the ptr</span><br><span class="line">_num_app:</span><br><span class="line">    .quad 5</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line">    .quad app_2_start</span><br><span class="line">    .quad app_3_start</span><br><span class="line">    .quad app_4_start</span><br><span class="line">    .quad app_4_end&#96;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Design it!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AppManager</span></span> &#123;</span><br><span class="line">    num_app: <span class="built_in">usize</span>,</span><br><span class="line">    current_app: <span class="built_in">usize</span>,</span><br><span class="line">    app_start: [<span class="built_in">usize</span>; MAX_APP_NUM + <span class="number">1</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// part of read in static init of AppManager</span></span><br><span class="line"><span class="keyword">let</span> num_app_ptr = _num_app <span class="keyword">as</span> <span class="built_in">usize</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">usize</span>;</span><br><span class="line"><span class="keyword">let</span> num_app = num_app_ptr.read_volatile();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> app_start: [<span class="built_in">usize</span>; MAX_APP_NUM + <span class="number">1</span>] = [<span class="number">0</span>; MAX_APP_NUM + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> app_start_raw: &amp;[<span class="built_in">usize</span>] =  core::slice::from_raw_parts(</span><br><span class="line">    num_app_ptr.add(<span class="number">1</span>), num_app + <span class="number">1</span></span><br><span class="line">);</span><br><span class="line">app_start[..=num_app].copy_from_slice(app_start_raw);</span><br></pre></td></tr></table></figure>

<p>Load App:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// part of code of copying to kernel</span></span><br><span class="line">asm!(<span class="string">"fence.i"</span>);</span><br><span class="line"><span class="comment">// clear app area</span></span><br><span class="line">core::slice::from_raw_parts_mut(</span><br><span class="line">    APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>,</span><br><span class="line">    APP_SIZE_LIMIT</span><br><span class="line">).fill(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> app_src = core::slice::from_raw_parts(</span><br><span class="line">    <span class="keyword">self</span>.app_start[app_id] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>,</span><br><span class="line">    <span class="keyword">self</span>.app_start[app_id + <span class="number">1</span>] - <span class="keyword">self</span>.app_start[app_id]</span><br><span class="line">);</span><br><span class="line"><span class="keyword">let</span> app_dst = core::slice::from_raw_parts_mut(</span><br><span class="line">    APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>,</span><br><span class="line">    app_src.len()</span><br><span class="line">);</span><br><span class="line">app_dst.copy_from_slice(app_src);</span><br></pre></td></tr></table></figure>

<p>Run each app!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run_next_app</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> app_manager = APP_MANAGER.exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> current_app = app_manager.get_current_app();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        app_manager.load_app(current_app);</span><br><span class="line">    &#125;</span><br><span class="line">    app_manager.move_to_next_app();</span><br><span class="line">    <span class="built_in">drop</span>(app_manager);</span><br><span class="line">    <span class="comment">// before this we have to drop local variables related to resources manually</span></span><br><span class="line">    <span class="comment">// and release the resources</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> &#123; <span class="function"><span class="keyword">fn</span> <span class="title">__restore</span></span>(cx_addr: <span class="built_in">usize</span>); &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __restore(KERNEL_STACK.push_context(</span><br><span class="line">            TrapContext::app_init_context(APP_BASE_ADDRESS, USER_STACK.get_sp())</span><br><span class="line">        ) <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">"Unreachable in batch::run_current_app!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main logic:</span></span><br><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"></span><br><span class="line">...above code</span><br><span class="line"><span class="comment">// load entry for trap</span></span><br><span class="line">trap::init()</span><br><span class="line"><span class="comment">// load app</span></span><br><span class="line">batch::run_next_app()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap4/" class="post-title-link" itemprop="url">rcore-handnote-4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-06 06:28:39" itemprop="dateModified" datetime="2025-05-06T06:28:39+00:00">2025-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>We don’t want a fixed physical addr for allocation, rather, we want a unified abstract interface for dynamic memory layout for app storage. We call it <strong>Virtual Address</strong></p>
<p>Safety: Every app will be allocated in its own virtual memory space, so each can’t interfere others.</p>
<p>Efficiency: Every app can coexist in same time without demand of reading outer peripherals to switch app.(With development of memory size)</p>
<p>We need <strong>MMU</strong>(Memory Management Unit) to achieve <strong>Address Translation</strong> for interview from virtual to physical.</p>
<p>Different designs occur.</p>
<hr>
<h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><h3 id="Segment-Design"><a href="#Segment-Design" class="headerlink" title="Segment Design"></a>Segment Design</h3><p><img src="/blog/.io//assets/Lab4-1.png" alt="alt text"></p>
<p>Each app exist in one fixed slot for one segment as $[0,bound)$, with a linear map by <strong>MMU</strong>.</p>
<p>Problem: Wasteful and inflexible</p>
<p>We may want a different linear map for each app， for example, its allocation for heap, data, code etc… So we can dispatch memory in more finer style, but it can’t resolve the problem because now even slot is dynamically allocated, it may still exist some free memory too small to reuse, cause the <strong>External Fragment</strong> rather than <strong>Internal Fragment</strong> which is the problem due to fixed slot.</p>
<h3 id="Paging-Design"><a href="#Paging-Design" class="headerlink" title="Paging Design"></a>Paging Design</h3><p><img src="/blog/.io//assets/Lab4-2.png" alt="alt text"><br>We could set a <strong>Protection bit</strong> as <code>r</code> for read, <code>w</code> for write, <code>x</code> for execution.</p>
<p>Another way is to inverse our mind, rather take a slot on memory, we take slot on <strong>MMU</strong>, it can map its slot(now we call it <strong>Page</strong>) for real physical memory layout. To adjust, we can take slice for <strong>Page</strong> to form <strong>Frame</strong> which is a smaller unit to suit physical memory layout, each app can take many <strong>Page Number</strong> for a <strong>Page Table</strong>, record the map.</p>
<h2 id="Page-Design"><a href="#Page-Design" class="headerlink" title="Page Design"></a>Page Design</h2><p><img src="/blog/.io//assets/Lab4-3.png" alt="alt text"></p>
<p><strong>SV39</strong> only use lower 39 bits rather whole 64 bits in design even bit width is 64 bits(it’s a fairly large amount!)</p>
<p>In a address, $[11:0]$ called <strong>Page Offset</strong>, and $[38:12]$ is the <strong>VPN</strong> which will be used for location of page and use offset to direct in one page(with 4KiB in one page).</p>
<p>We should modify <code>satp</code> to open Paging for S and U-level memory.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PAGE_SIZE: <span class="built_in">usize</span> = <span class="number">4096</span></span><br><span class="line"><span class="keyword">const</span> PAGE_SIZE_BIT: <span class="built_in">usize</span> = <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>Page Size and offset to slice physical addr.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/address.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PhysAddr &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">floor</span></span>(&amp;<span class="keyword">self</span>) -&gt; PhysPageNum &#123; PhysPageNum(<span class="keyword">self</span>.<span class="number">0</span> / PAGE_SIZE) &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">ceil</span></span>(&amp;<span class="keyword">self</span>) -&gt; PhysPageNum &#123; PhysPageNum((<span class="keyword">self</span>.<span class="number">0</span> + PAGE_SIZE - <span class="number">1</span>) / PAGE_SIZE) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Page Entry to bundle permission and physical page.</p>
<p><img src="/blog/.io//assets/Lab4-4.png" alt></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">ppn</span></span>(&amp;<span class="keyword">self</span>) -&gt; PhysPageNum &#123;</span><br><span class="line">	(<span class="keyword">self</span>.bits &gt;&gt; <span class="number">10</span> &amp; ((<span class="number">1usize</span> &lt;&lt; <span class="number">44</span>) - <span class="number">1</span>)).into()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">flags</span></span>(&amp;<span class="keyword">self</span>) -&gt; PTEFlags &#123;</span><br><span class="line">	PTEFlags::from_bits(<span class="keyword">self</span>.bits <span class="keyword">as</span> <span class="built_in">u8</span>).unwrap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Usually, a simple design for page manager would be a linear map from base addr and follow up. But actually it will take a huge amount of memory due to the storage of offset by base addr for each app.</p>
<p>A finer design is from <strong>Trie</strong>. We will take index slice for each 8 bits(it will fit in to 4KB just right!), it means for each slice has 512 states, and link those state up, form a tree. Usually with 3-level for <strong>Page Index</strong>. Total 27 bits.</p>
<p>Virtual Page will reserve 27 bits for the index slice and 12 bits for offset for certain page. Total 39 bits.</p>
<p>When we transform a virtual addr to physical one, we will do the following exposition reversely.</p>
<h2 id="Page-Management-Design"><a href="#Page-Management-Design" class="headerlink" title="Page Management Design"></a>Page Management Design</h2><p>A simple allocation for page(rather management!) is stack style.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackFrameAllocator</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">usize</span>,  <span class="comment">//空闲内存的起始物理页号</span></span><br><span class="line">    end: <span class="built_in">usize</span>,      <span class="comment">//空闲内存的结束物理页号</span></span><br><span class="line">    recycled: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Based on Allocation, we can design <strong>Page Table</strong>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/frame_allocator.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">FrameTracker</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> ppn: PhysPageNum,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> FrameTracker &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(ppn: PhysPageNum) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// page cleaning</span></span><br><span class="line">        <span class="keyword">let</span> bytes_array = ppn.get_bytes_array();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> bytes_array &#123;</span><br><span class="line">            *i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ppn &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageTable</span></span> &#123;</span><br><span class="line">    root_ppn: PhysPageNum,</span><br><span class="line">    frames: <span class="built_in">Vec</span>&lt;FrameTracker&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It means for one physical page, we will record each allocation by vector of FrameTracker as a representation of real <strong>Frame</strong> after the root.</p>
<p>We should design transformation from virtual addr to physical addr.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for each idxs represent index slices of virtual addr.</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> pte = &amp;<span class="keyword">mut</span> ppn.get_pte_array()[idxs[i]];</span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">		result = <span class="literal">Some</span>(pte);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !pte.is_valid() &#123;</span><br><span class="line">		<span class="keyword">let</span> frame = frame_alloc().unwrap();</span><br><span class="line">		<span class="comment">// create or return None</span></span><br><span class="line">		*pte = PageTableEntry::new(frame.ppn, PTEFlags::V);</span><br><span class="line">		<span class="keyword">self</span>.frames.push(frame);</span><br><span class="line">	&#125;</span><br><span class="line">	ppn = pte.ppn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Page-Map-Design"><a href="#Page-Map-Design" class="headerlink" title="Page Map Design"></a>Page Map Design</h2><p>Based on our abstraction, we need a design for <code>MapArea</code> to given a map from continuous virtual address(no matter their corresponding page!) to physical address.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MapArea</span></span> &#123;</span><br><span class="line">    vpn_range: VPNRange,</span><br><span class="line">    data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,</span><br><span class="line">    map_type: MapType,</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Based on continuous virtual address map, we can define discontinuous map for one app.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemorySet</span></span> &#123;</span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="built_in">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// impl MemorySet</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">push</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> map_area: MapArea, data: <span class="built_in">Option</span>&lt;&amp;[<span class="built_in">u8</span>]&gt;) &#123;</span><br><span class="line">	<span class="comment">// map range of virtual addr in allocation in page_table</span></span><br><span class="line">	map_area.map(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.page_table);</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(data) = data &#123;</span><br><span class="line">		map_area.copy_data(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.page_table, data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">self</span>.areas.push(map_area);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In Each <code>MapArea</code> allocated for some key-value for virtual-physical addr, it will allocate the same for <code>PageTable</code> for <strong>Frame</strong>.</p>
<hr>
<h2 id="Allocation-Space"><a href="#Allocation-Space" class="headerlink" title="Allocation Space"></a>Allocation Space</h2><p>To open SV39, we should write instruction for <code>satp</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">token</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="number">8usize</span> &lt;&lt; <span class="number">60</span> | <span class="keyword">self</span>.root_ppn.<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> MemorySet &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">activate</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> satp = <span class="keyword">self</span>.page_table.token();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            satp::write(satp);</span><br><span class="line">            asm!(<span class="string">"sfence.vma"</span> :::: <span class="string">"volatile"</span>);</span><br><span class="line">			<span class="comment">// sfence.vma is a special instruction to clear `Translaton Lookaside Buffer` which is used for quick search for memory addr to reduce performance expenses.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Therefore, it will fill current root of physical page number as activation.</p>
<p>Notice that we should make instruction contigeous for <code>SV39</code> open in physical address to amend the gap of transformation of address before and after open.</p>
<h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>Initiation for Kernel memory layout.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> memory_set = Self::new_bare();</span><br><span class="line"><span class="comment">// map trampoline</span></span><br><span class="line">memory_set.map_trampoline();</span><br><span class="line">memory_set.push(MapArea::new(</span><br><span class="line">	(stext <span class="keyword">as</span> <span class="built_in">usize</span>).into(),</span><br><span class="line">	(etext <span class="keyword">as</span> <span class="built_in">usize</span>).into(),</span><br><span class="line">	MapType::Identical,</span><br><span class="line">	MapPermission::R | MapPermission::X,</span><br><span class="line">), <span class="literal">None</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"mapping .rodata section"</span>);</span><br><span class="line"><span class="comment">// other layout ...</span></span><br></pre></td></tr></table></figure>

<p>Initiation for App memory layout.</p>
<p>Previously, we will cut off <code>elf</code> part of binary of apps, now we load it and extract useful infos, s.t. Permissions.</p>
<p><code>MemorySet</code> should allocate storage of execution code with its permissions, allocate user stack and trap context at top of the memory layout.</p>
<p>Output <code>MemorySet</code>, user stack top, entry point addr.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> max_end_vpn = VirtPageNum(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> max_end_va: VirtAddr = max_end_vpn.into();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> user_stack_bottom: <span class="built_in">usize</span> = max_end_va.into();</span><br><span class="line"><span class="comment">// guard page</span></span><br><span class="line">user_stack_bottom += PAGE_SIZE;</span><br><span class="line"><span class="keyword">let</span> user_stack_top = user_stack_bottom + USER_STACK_SIZE;</span><br><span class="line">memory_set.push(MapArea::new(</span><br><span class="line">	TRAP_CONTEXT.into(),</span><br><span class="line">	TRAMPOLINE.into(),</span><br><span class="line">	MapType::Framed,</span><br><span class="line">	MapPermission::R | MapPermission::W,</span><br><span class="line">), <span class="literal">None</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="App"><a href="#App" class="headerlink" title="App"></a>App</h3><p>A problem is that separation of Kernel and App will also isolate <strong>Trap</strong>, the process need info from App to Kernel but App can’t see it. Therefore, we need a transfer operation. We achieve this by storing related info in <code>TrapContext</code>.</p>
<p>(Because there’s no more register to store these without breaking state like <code>sscratch</code> designed for kernel stack.)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/trap/context.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrapContext</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> x: [<span class="built_in">usize</span>; <span class="number">32</span>],</span><br><span class="line">    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line">    <span class="keyword">pub</span> sepc: <span class="built_in">usize</span>,</span><br><span class="line">	<span class="comment">// new:</span></span><br><span class="line">    <span class="keyword">pub</span> kernel_satp: <span class="built_in">usize</span>, </span><br><span class="line">    <span class="keyword">pub</span> kernel_sp: <span class="built_in">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> trap_handler: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice that we also need to modify below to trigger <code>satp</code> and specify corresponding(U-level, S-level <code>satp</code>) physical page number to change state.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># __alltraps:</span><br><span class="line"></span><br><span class="line"># load kernel_satp into t0</span><br><span class="line">ld t0, 34*8(sp)</span><br><span class="line"># load trap_handler into t1</span><br><span class="line">ld t1, 36*8(sp)</span><br><span class="line"># move to kernel_sp</span><br><span class="line">ld sp, 35*8(sp)</span><br><span class="line"># switch to kernel space</span><br><span class="line">csrw satp, t0</span><br><span class="line">sfence.vma</span><br><span class="line"># jump to trap_handler</span><br><span class="line">jr t1</span><br><span class="line"></span><br><span class="line"># __restore:</span><br><span class="line"># a0: *TrapContext in user space(Constant); a1: user space token</span><br><span class="line"># switch to user space</span><br><span class="line">csrw satp, a1</span><br><span class="line">sfence.vma</span><br><span class="line">csrw sscratch, a0</span><br></pre></td></tr></table></figure>

<p>To amend the problem of contigeous instructions after switch, we need to adjust memory layout for <code>trampoline</code> which is in the same location in U-level and S-level(<strong>unified for all app to trap!</strong>). It will be placed at highest virtual page.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># os&#x2F;src&#x2F;linker.ld</span><br><span class="line"></span><br><span class="line">    stext &#x3D; .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">+        . &#x3D; ALIGN(4K);</span><br><span class="line">+        strampoline &#x3D; .;</span><br><span class="line">+        *(.text.trampoline);</span><br><span class="line">+        . &#x3D; ALIGN(4K);</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>We modify rather raw handler and restore, due to virtual address, we need to adjust it for <code>trampoline</code> rather the address we had code!(<strong>it’s virtual!</strong>)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">trap_handler</span></span>() -&gt; ! &#123;</span><br><span class="line">    set_kernel_trap_entry();</span><br><span class="line">    <span class="keyword">let</span> cx = current_trap_cx();</span><br><span class="line">    <span class="keyword">let</span> scause = scause::read();</span><br><span class="line">    <span class="keyword">let</span> stval = stval::read();</span><br><span class="line">    <span class="keyword">match</span> scause.cause() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    trap_return();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">trap_return</span></span>() -&gt; ! &#123;</span><br><span class="line">    set_user_trap_entry();</span><br><span class="line">    <span class="keyword">let</span> trap_cx_ptr = TRAP_CONTEXT;</span><br><span class="line">    <span class="keyword">let</span> user_satp = current_user_token();</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">__alltraps</span></span>();</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">__restore</span></span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> restore_va = __restore <span class="keyword">as</span> <span class="built_in">usize</span> - __alltraps <span class="keyword">as</span> <span class="built_in">usize</span> + TRAMPOLINE;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">"fence.i"</span>,</span><br><span class="line">            <span class="string">"jr &#123;restore_va&#125;"</span>,</span><br><span class="line">            restore_va = <span class="keyword">in</span>(reg) restore_va,</span><br><span class="line">            <span class="keyword">in</span>(<span class="string">"a0"</span>) trap_cx_ptr,</span><br><span class="line">            <span class="keyword">in</span>(<span class="string">"a1"</span>) user_satp,</span><br><span class="line">            options(noreturn)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">"Unreachable in back_to_user!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then map the virtual address for it up to the physical address for unifying.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/config.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> TRAMPOLINE: <span class="built_in">usize</span> = <span class="built_in">usize</span>::MAX - PAGE_SIZE + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> MemorySet &#123;</span><br><span class="line">    <span class="comment">/// Mention that trampoline is not collected by areas.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">map_trampoline</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.page_table.map(</span><br><span class="line">            VirtAddr::from(TRAMPOLINE).into(),</span><br><span class="line">            PhysAddr::from(strampoline <span class="keyword">as</span> <span class="built_in">usize</span>).into(),</span><br><span class="line">            PTEFlags::R | PTEFlags::X,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We should adjust <code>TaskControlBlock</code> for the same reason, record each <code>Trap</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet,</span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum,</span><br><span class="line">    <span class="keyword">pub</span> base_size: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It will read data getting from elf, get trap contexr ppn, its kernel stack bottom and top, and then initiate trap context.</p>
<p>Here the part of task control initiation:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> TaskContext &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">goto_trap_return</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            ra: trap_return <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">            s: [<span class="number">0</span>; <span class="number">12</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fn new(elf_data: &amp;[u8], app_id: usize) -&gt; Self </span></span><br><span class="line"><span class="keyword">let</span> task_control_block = <span class="keyword">Self</span> &#123;</span><br><span class="line">	task_status,</span><br><span class="line">	task_cx: TaskContext::goto_trap_return(kernel_stack_top),</span><br><span class="line">	memory_set,</span><br><span class="line">	trap_cx_ppn,</span><br><span class="line">	base_size: user_sp,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// prepare TrapContext in user space</span></span><br><span class="line"><span class="keyword">let</span> trap_cx = task_control_block.get_trap_cx();</span><br><span class="line">*trap_cx = TrapContext::app_init_context(</span><br><span class="line">	entry_point,</span><br><span class="line">	user_sp,</span><br><span class="line">	KERNEL_SPACE.exclusive_access().token(),</span><br><span class="line">	kernel_stack_top,</span><br><span class="line">	trap_handler <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">);</span><br><span class="line">task_control_block</span><br></pre></td></tr></table></figure>









      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap5/" class="post-title-link" itemprop="url">rcore-handnote-5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-06 06:28:39" itemprop="dateModified" datetime="2025-05-06T06:28:39+00:00">2025-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>After the demand of code execution one by one, we want to introduce <strong>Process</strong> which will be a full space-time description of execution process of binary file in OS. It means for one process, it should hold independent resources to be executed.</p>
<p>After <strong>Process</strong>, <strong>Thread</strong> and <strong>Coroutine</strong> are also developed in growth of OS. They are different in resources taken up, usually, <strong>Thread</strong> will be in one process and hold their own independent stack and workflow; <strong>Coroutine</strong> will be in one <strong>Thread</strong> and hold their own independent workflow.</p>
<hr>
<h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><p>Every process need independent memory layout, can be dispatch by cpu. It’s the functionality based on <strong>Task</strong>, after that, each process can <strong>Fork</strong> their own children processes, so there’s a workflow in time discrepancy. Its resource can’t be recycled in time due to children processes, we need to mark it as <strong>Zombie Process</strong>.</p>
<p>To clarify which is children, which is parent, and each isolated process, we mark each with <strong>PID-Process Identifier</strong>. Notice if we fork a process, it will be same as parent only <code>a0</code> which is the register called for return will be different, parent process return new PID of child process, child process return 0 as none of fork.</p>
<ul>
<li>fork: copy a process state(like <code>sp</code> etc…) as its child process.</li>
<li>waitpid: wait a child become zombie and recycle all resources.</li>
<li>exec: clear a process state and load a execution file.</li>
</ul>
<hr>
<h3 id="Data-Constructon"><a href="#Data-Constructon" class="headerlink" title="Data Constructon"></a>Data Constructon</h3><p>We will recycle all presumed pid by <code>PidAllocator</code>, No need to worry about previous pid used.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PidHandle</span></span>(<span class="keyword">pub</span> <span class="built_in">usize</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PidAllocator</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">usize</span>,</span><br><span class="line">    recycled: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl PidAllocator</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; PidHandle &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(pid) = <span class="keyword">self</span>.recycled.pop() &#123;</span><br><span class="line">		PidHandle(pid)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">self</span>.current += <span class="number">1</span>;</span><br><span class="line">		PidHandle(<span class="keyword">self</span>.current - <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Therefore, if one pid recycled, it deallocated memory can be reused, we will define its <code>KernelStack</code> addr by pid.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/pid.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">KernelStack</span></span> &#123;</span><br><span class="line">    pid: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">kernel_stack_position</span></span>(app_id: <span class="built_in">usize</span>) -&gt; (<span class="built_in">usize</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> top = TRAMPOLINE - app_id * (KERNEL_STACK_SIZE + PAGE_SIZE);</span><br><span class="line">    <span class="keyword">let</span> bottom = top - KERNEL_STACK_SIZE;</span><br><span class="line">    (bottom, top)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl KernelStack</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">push_on_top</span></span>&lt;T&gt;(&amp;<span class="keyword">self</span>, value: T) -&gt; *<span class="keyword">mut</span> T <span class="keyword">where</span></span><br><span class="line">	T: <span class="built_in">Sized</span>, &#123;</span><br><span class="line">	<span class="keyword">let</span> kernel_stack_top = <span class="keyword">self</span>.get_top();</span><br><span class="line">	<span class="keyword">let</span> ptr_mut = (kernel_stack_top - core::mem::size_of::&lt;T&gt;()) <span class="keyword">as</span> *<span class="keyword">mut</span> T;</span><br><span class="line">	<span class="keyword">unsafe</span> &#123; *ptr_mut = value; &#125;</span><br><span class="line">	ptr_mut</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_top</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> (_, kernel_stack_top) = kernel_stack_position(<span class="keyword">self</span>.pid);</span><br><span class="line">	kernel_stack_top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> KernelStack &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> (kernel_stack_bottom, _) = kernel_stack_position(<span class="keyword">self</span>.pid);</span><br><span class="line">        <span class="keyword">let</span> kernel_stack_bottom_va: VirtAddr = kernel_stack_bottom.into();</span><br><span class="line">        KERNEL_SPACE</span><br><span class="line">            .exclusive_access()</span><br><span class="line">            .remove_area_with_start_vpn(kernel_stack_bottom_va.into());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to construct <code>TaskControlBlock</code> for parent and children process.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// new:</span></span><br><span class="line">    <span class="keyword">pub</span> parent: <span class="built_in">Option</span>&lt;Weak&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> children: <span class="built_in">Vec</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl TaskControlBlockInner</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_zombie</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">	<span class="keyword">self</span>.get_status() == TaskStatus::Zombie</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TaskManager</code> manage all tasks and cpu dispatch, we will separate only tasks management for <code>TaskManager</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/manager.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskManager</span></span> &#123;</span><br><span class="line">    ready_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> TASK_MANAGER: UPSafeCell&lt;TaskManager&gt; = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        UPSafeCell::new(TaskManager::new())</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_task</span></span>(task: Arc&lt;TaskControlBlock&gt;) &#123;</span><br><span class="line">    TASK_MANAGER.exclusive_access().add(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_task</span></span>() -&gt; <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    TASK_MANAGER.exclusive_access().fetch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And cpu dispatch for newly introduced <strong>Processor</strong>.<br>We introduce a <strong>idle process</strong> that used to call other process.</p>
<ul>
<li>Why not direct call next by previous one? rather use idle process?</li>
<li>Separate idle process for <strong>start</strong> and others for its own, then dispatch data won’t occur in other process and make the dispatch process invisible for <strong>Trap</strong> for each process.</li>
</ul>
<p>The whole workflow would be:</p>
<ul>
<li>idle process fetch task and switch</li>
<li>task run out of its time or finish</li>
<li>task switch to idle process</li>
<li>repeat…</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Processor</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">	<span class="comment">// idle process of current cpu</span></span><br><span class="line">    idle_task_cx: TaskContext,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> PROCESSOR: UPSafeCell&lt;Processor&gt; = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        UPSafeCell::new(Processor::new())</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run_tasks() </span></span><br><span class="line"><span class="comment">// loop to fetch task and switch possible task</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = fetch_task() &#123;</span><br><span class="line">    <span class="keyword">let</span> idle_task_cx_ptr = processor.get_idle_task_cx_ptr();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> next_task_cx_ptr = &amp;task_inner.task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line">    task_inner.task_status = TaskStatus::Running;</span><br><span class="line">    <span class="built_in">drop</span>(task_inner);</span><br><span class="line">    processor.current = <span class="literal">Some</span>(task);</span><br><span class="line">    <span class="built_in">drop</span>(processor);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __switch(</span><br><span class="line">            idle_task_cx_ptr,</span><br><span class="line">            next_task_cx_ptr,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch to idle process if one task run out of its time.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">schedule</span></span>(switched_task_cx_ptr: *<span class="keyword">mut</span> TaskContext) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> processor = PROCESSOR.exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> idle_task_cx_ptr = processor.get_idle_task_cx_ptr();</span><br><span class="line">    <span class="built_in">drop</span>(processor);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __switch(</span><br><span class="line">            switched_task_cx_ptr,</span><br><span class="line">            idle_task_cx_ptr,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Dispatch-Construction"><a href="#Dispatch-Construction" class="headerlink" title="Dispatch Construction"></a>Dispatch Construction</h3><p>Previously, we use <code>suspend_current_and_run_next</code> to pause task and switch to next, now we need to adapt it to process design.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">suspend_current_and_run_next</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> task = take_current_task().unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- access current TCB exclusively</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> task_cx_ptr = &amp;<span class="keyword">mut</span> task_inner.task_cx <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext;</span><br><span class="line">    task_inner.task_status = TaskStatus::Ready;</span><br><span class="line">    <span class="built_in">drop</span>(task_inner);</span><br><span class="line">    <span class="comment">// ---- stop exclusively accessing current PCB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add to task deque</span></span><br><span class="line">    add_task(task);</span><br><span class="line">    <span class="comment">// change current to idle process</span></span><br><span class="line">    schedule(task_cx_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In previous case, task won’t be created by its parent task, but process will. So, if its <code>TrapContext</code> has been recycled, we need to refactor our <code>trap_handler</code> for such case.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn trap_handler() -&gt; !</span></span><br><span class="line">Trap::Exception(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">    <span class="comment">// jump to next instruction anyway</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> cx = current_trap_cx();</span><br><span class="line">    cx.sepc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// syscall may create new process and change trap context.</span></span><br><span class="line">    <span class="keyword">let</span> result = syscall(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>]]);</span><br><span class="line">    <span class="comment">// wether cx is changed or not, we will refetch it.</span></span><br><span class="line">    cx = current_trap_cx();</span><br><span class="line">    cx.x[<span class="number">10</span>] = result <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Now we will construct <code>fork</code>, <code>exec</code>, <code>waitpid</code>,<code>exit</code>.</p>
<h4 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h4><p>We need to copy all memory layout and its task state. Then reallocate new kernel stack for it.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl MemorySet</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_existed_user</span></span>(user_space: &amp;MemorySet) -&gt; MemorySet &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> memory_set = Self::new_bare();</span><br><span class="line">    <span class="comment">// map trampoline</span></span><br><span class="line">    memory_set.map_trampoline();</span><br><span class="line">    <span class="comment">// copy data sections/trap_context/user_stack</span></span><br><span class="line">    <span class="keyword">for</span> area <span class="keyword">in</span> user_space.areas.iter() &#123;</span><br><span class="line">        <span class="keyword">let</span> new_area = MapArea::from_another(area);</span><br><span class="line">        memory_set.push(new_area, <span class="literal">None</span>);</span><br><span class="line">        <span class="comment">// copy data from another space</span></span><br><span class="line">        <span class="keyword">for</span> vpn <span class="keyword">in</span> area.vpn_range &#123;</span><br><span class="line">            <span class="keyword">let</span> src_ppn = user_space.translate(vpn).unwrap().ppn();</span><br><span class="line">            <span class="keyword">let</span> dst_ppn = memory_set.translate(vpn).unwrap().ppn();</span><br><span class="line">            dst_ppn.get_bytes_array().copy_from_slice(src_ppn.get_bytes_array());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memory_set</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl TaskControlBlock</span></span><br><span class="line"><span class="comment">// fn fork</span></span><br><span class="line"><span class="keyword">let</span> trap_cx_ppn = memory_set</span><br><span class="line">    .translate(VirtAddr::from(TRAP_CONTEXT).into())</span><br><span class="line">    .unwrap()</span><br><span class="line">    .ppn();</span><br><span class="line"><span class="comment">// alloc a pid and a kernel stack in kernel space</span></span><br><span class="line"><span class="keyword">let</span> pid_handle = pid_alloc();</span><br><span class="line"><span class="keyword">let</span> kernel_stack = KernelStack::new(&amp;pid_handle);</span><br><span class="line"><span class="keyword">let</span> kernel_stack_top = kernel_stack.get_top();</span><br><span class="line"><span class="keyword">let</span> task_control_block = Arc::new(TaskControlBlock &#123;</span><br><span class="line">    pid: pid_handle,</span><br><span class="line">    kernel_stack,</span><br><span class="line">    inner: <span class="keyword">unsafe</span> &#123; UPSafeCell::new(TaskControlBlockInner &#123;</span><br><span class="line">        trap_cx_ppn,</span><br><span class="line">        base_size: parent_inner.base_size,</span><br><span class="line">        task_cx: TaskContext::goto_trap_return(kernel_stack_top),</span><br><span class="line">        task_status: TaskStatus::Ready,</span><br><span class="line">        memory_set,</span><br><span class="line">        parent: <span class="literal">Some</span>(Arc::downgrade(<span class="keyword">self</span>)),</span><br><span class="line">        children: <span class="built_in">Vec</span>::new(),</span><br><span class="line">        exit_code: <span class="number">0</span>,</span><br><span class="line">    &#125;)&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// add child</span></span><br><span class="line">parent_inner.children.push(task_control_block.clone());</span><br><span class="line"><span class="comment">// modify kernel_sp in trap_cx</span></span><br><span class="line"><span class="comment">// **** access children PCB exclusively</span></span><br><span class="line"><span class="keyword">let</span> trap_cx = task_control_block.inner_exclusive_access().get_trap_cx();</span><br><span class="line">trap_cx.kernel_sp = kernel_stack_top;</span><br></pre></td></tr></table></figure>

<p>Finally, implement <code>sys_fork</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_fork</span></span>() -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current_task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> new_task = current_task.fork();</span><br><span class="line">    <span class="keyword">let</span> new_pid = new_task.pid.<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> trap_cx = new_task.inner_exclusive_access().get_trap_cx();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for child process, fork returns 0</span></span><br><span class="line">    trap_cx.x[<span class="number">10</span>] = <span class="number">0</span>;  <span class="comment">//x[10] is a0 reg</span></span><br><span class="line"></span><br><span class="line">    add_task(new_task);</span><br><span class="line">    new_pid <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can see that if <code>trap_handler</code> call <code>sys_fork</code>, parent process <code>x[10]</code> would be <code>new_pid</code> as return value.</p>
<h4 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a>Exec</h4><p>If we want to execute a task by its name, we need to first load string in app load.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/build.rs</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">writeln!</span>(f, r#<span class="string">"</span></span><br><span class="line"><span class="string">.global _app_names</span></span><br><span class="line"><span class="string">_app_names:"</span>#)?;</span><br><span class="line"><span class="keyword">for</span> app <span class="keyword">in</span> apps.iter() &#123;</span><br><span class="line">    <span class="built_in">writeln!</span>(f, <span class="string">r#"    .string "&#123;&#125;""#</span>, app)?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># link_app.S</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">_app_names:</span><br><span class="line">    .string &quot;exit&quot;</span><br><span class="line">    .string &quot;fantastic_text&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Construct <code>APP_NAMES</code> as global state in OS.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/loader.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// APP_NAMES: Vec&lt;&amp;'static str&gt; &#123;...</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..num_app &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> end = start;</span><br><span class="line">    <span class="keyword">while</span> end.read_volatile() != <span class="string">'\0'</span> <span class="keyword">as</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">        end = end.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> slice = core::slice::from_raw_parts(start, end <span class="keyword">as</span> <span class="built_in">usize</span> - start <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">str</span> = core::<span class="built_in">str</span>::from_utf8(slice).unwrap();</span><br><span class="line">    v.push(<span class="built_in">str</span>);</span><br><span class="line">    start = end.add(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When execute a new binary file, we need to read it and extract all state to replace original one.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> (memory_set, user_sp, entry_point) = MemorySet::from_elf(elf_data);</span><br><span class="line">        <span class="keyword">let</span> trap_cx_ppn = memory_set</span><br><span class="line">            .translate(VirtAddr::from(TRAP_CONTEXT).into())</span><br><span class="line">            .unwrap()</span><br><span class="line">            .ppn();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// **** access inner exclusively</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner_exclusive_access();</span><br><span class="line">        inner.memory_set = memory_set;</span><br><span class="line">        inner.trap_cx_ppn = trap_cx_ppn;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> trap_cx = inner.get_trap_cx();</span><br><span class="line">        *trap_cx = TrapContext::app_init_context(</span><br><span class="line">            entry_point,</span><br><span class="line">            user_sp,</span><br><span class="line">            KERNEL_SPACE.exclusive_access().token(),</span><br><span class="line">            <span class="keyword">self</span>.kernel_stack.get_top(),</span><br><span class="line">            trap_handler <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// **** stop exclusively accessing inner automatically</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We will read input <code>str</code> as a ptr and replace current task state.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exec</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> token = current_user_token();</span><br><span class="line">    <span class="keyword">let</span> path = translated_str(token, path);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(data) = get_app_data_by_name(path.as_str()) &#123;</span><br><span class="line">        <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">        task.exec(data);</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Exit"><a href="#Exit" class="headerlink" title="Exit"></a>Exit</h4><p>When a task exit, it will return a <strong>exit code</strong> assigned by app if successfully or kernel if anomaly.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn exit_current_and_run_next(exit_code:i32)</span></span><br><span class="line">    inner.task_status = TaskStatus::Zombie;</span><br><span class="line">    inner.exit_code = exit_code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move all its children to the initial process</span></span><br><span class="line">    <span class="comment">// ++++++ access initproc TCB exclusively</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> initproc_inner = INITPROC.inner_exclusive_access();</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> inner.children.iter() &#123;</span><br><span class="line">            child.inner_exclusive_access().parent = <span class="literal">Some</span>(Arc::downgrade(&amp;INITPROC));</span><br><span class="line">            initproc_inner.children.push(child.clone());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ++++++ stop exclusively accessing parent PCB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear all memory.</span></span><br><span class="line">    inner.children.clear();</span><br><span class="line">    inner.memory_set.recycle_data_pages();</span><br><span class="line">    <span class="built_in">drop</span>(inner);</span><br><span class="line">    <span class="comment">// **** stop exclusively accessing current PCB</span></span><br><span class="line">    <span class="comment">// drop task manually to maintain rc correctly</span></span><br><span class="line">    <span class="built_in">drop</span>(task);</span><br><span class="line">    <span class="comment">// use _unused replace original context, which will be recycled by rust.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> _unused = TaskContext::zero_init();</span><br><span class="line">    schedule(&amp;<span class="keyword">mut</span> _unused <span class="keyword">as</span> *<span class="keyword">mut</span> _);</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exit</span></span>(exit_code: <span class="built_in">i32</span>) -&gt; ! &#123;</span><br><span class="line">    exit_current_and_run_next(exit_code);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">"Unreachable in sys_exit!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WaitPid"><a href="#WaitPid" class="headerlink" title="WaitPid"></a>WaitPid</h4><p>WaitPid will return <code>-1</code> if there’s no specified pid process exist, if it’s running, return <code>-2</code>, finally, if it finished, recycle it and return <code>0</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sys_waitpid(pid:uisze, exit_code_ptr:*mut i32) -&gt; isize</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -1 case</span></span><br><span class="line"><span class="comment">// search task manager and find (task_block)</span></span><br><span class="line">|p| &#123;pid == -<span class="number">1</span> || pid <span class="keyword">as</span> <span class="built_in">usize</span> == p.getpid()&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pair = <span class="comment">// search task managers and find (idx,task_block)</span></span><br><span class="line">p.inner_exclusive_access().is_zombie() &amp;&amp; (pid == -<span class="number">1</span> || pid <span class="keyword">as</span> <span class="built_in">usize</span> == p.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>((idx,_)) = pair &#123;</span><br><span class="line">    <span class="keyword">let</span> child = inner.children.remove(idx);</span><br><span class="line">    <span class="comment">// confirm that child will be deallocated after removing from children list</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(Arc::strong_count(&amp;child), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> found_pid = child.getpid();</span><br><span class="line">    <span class="comment">// ++++ temporarily access child TCB exclusively</span></span><br><span class="line">    <span class="keyword">let</span> exit_code = child.inner_exclusive_access().exit_code;</span><br><span class="line">    <span class="comment">// ++++ stop exclusively accessing child PCB</span></span><br><span class="line">    *translated_refmut(inner.memory_set.token(), exit_code_ptr) = exit_code;</span><br><span class="line">    found_pid <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// pid process is running</span></span><br><span class="line">    -<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">wait</span></span>(exit_code: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> sys_waitpid(-<span class="number">1</span>, exit_code <span class="keyword">as</span> *<span class="keyword">mut</span> _) &#123;</span><br><span class="line">            -<span class="number">2</span> =&gt; &#123; yield_(); &#125;</span><br><span class="line">            <span class="comment">// -1 or a real pid</span></span><br><span class="line">            exit_pid =&gt; <span class="keyword">return</span> exit_pid,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><a class="page-number" href="/blog/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/blog/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/60/">60</a><a class="extend next" rel="next" href="/blog/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
